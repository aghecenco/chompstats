[{"user": {"following_url": "https://api.github.com/users/liujing2/following{/other_user}", "url": "https://api.github.com/users/liujing2", "site_admin": false, "gists_url": "https://api.github.com/users/liujing2/gists{/gist_id}", "node_id": "MDQ6VXNlcjM5Njg0NjQ5", "starred_url": "https://api.github.com/users/liujing2/starred{/owner}{/repo}", "gravatar_id": "", "id": 39684649, "events_url": "https://api.github.com/users/liujing2/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/39684649?v=4", "login": "liujing2", "repos_url": "https://api.github.com/users/liujing2/repos", "subscriptions_url": "https://api.github.com/users/liujing2/subscriptions", "followers_url": "https://api.github.com/users/liujing2/followers", "html_url": "https://github.com/liujing2", "received_events_url": "https://api.github.com/users/liujing2/received_events", "type": "User", "organizations_url": "https://api.github.com/users/liujing2/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/1", "body": "@andreeaflorescu @sameo @jiangliu @chao-p ", "updated_at": "2019-07-30T06:48:12Z", "url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/comments/516288021", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-allocator/pull/1#issuecomment-516288021", "created_at": "2019-07-30T06:48:12Z", "id": 516288021, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNjI4ODAyMQ=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/1", "body": "@liujing2 there is [a bug](https://github.com/cookiecutter/cookiecutter/issues/1041) when generating repositories from templates which results in the submodule rust-vmm-ci not being initialized. This is making the buildkite pipeline fail.\r\n\r\nCan you add a first commit that initializes the submodule by running:\r\n```\r\ngit submodule add https://github.com/rust-vmm/rust-vmm-ci.git\r\ngit add rust-vmm-ci\r\ngit commit -s\r\n```", "updated_at": "2019-07-30T08:28:37Z", "url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/comments/516319937", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-allocator/pull/1#issuecomment-516319937", "created_at": "2019-07-30T08:28:03Z", "id": 516319937, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNjMxOTkzNw=="}, {"user": {"following_url": "https://api.github.com/users/liujing2/following{/other_user}", "url": "https://api.github.com/users/liujing2", "site_admin": false, "gists_url": "https://api.github.com/users/liujing2/gists{/gist_id}", "node_id": "MDQ6VXNlcjM5Njg0NjQ5", "starred_url": "https://api.github.com/users/liujing2/starred{/owner}{/repo}", "gravatar_id": "", "id": 39684649, "events_url": "https://api.github.com/users/liujing2/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/39684649?v=4", "login": "liujing2", "repos_url": "https://api.github.com/users/liujing2/repos", "subscriptions_url": "https://api.github.com/users/liujing2/subscriptions", "followers_url": "https://api.github.com/users/liujing2/followers", "html_url": "https://github.com/liujing2", "received_events_url": "https://api.github.com/users/liujing2/received_events", "type": "User", "organizations_url": "https://api.github.com/users/liujing2/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/1", "body": "> @liujing2 there is [a bug](https://github.com/cookiecutter/cookiecutter/issues/1041) when generating repositories from templates which results in the submodule rust-vmm-ci not being initialized. This is making the buildkite pipeline fail.\r\n> \r\n> Can you add a first commit that initializes the submodule by running:\r\n> \r\n> ```\r\n> git submodule add https://github.com/rust-vmm/rust-vmm-ci.git\r\n> git add rust-vmm-ci\r\n> git commit -s\r\n> ```\r\n\r\nThis is added. ", "updated_at": "2019-08-01T02:47:13Z", "url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/comments/517096645", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-allocator/pull/1#issuecomment-517096645", "created_at": "2019-08-01T02:47:13Z", "id": 517096645, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNzA5NjY0NQ=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/1", "body": "It seems we're running a bit in circle between that PR and the [vm-device\r\none](https://github.com/rust-vmm/vm-device/pull/3). \r\n\r\nI'd like to use this PR to discuss about an updated design.\r\n\r\n## vm-allocator\r\n\r\nThe vm-allocator crate is managing guest resources, mainly related to devices.\r\nWhen the VMM is responsible for directly reseving and exposing resources to a\r\nguest, the vm-allocator crate allocates, reserves and manages resources. Its\r\nmain requirements are:\r\n\r\n- Keep track of a guest's reserved and allocated resources. In some cases, the\r\n  vm-allocator will allocate and expose resources for a guest to consume, while\r\n  in others it only keeps track of resources that are allocated from the guest.\r\n  For example, when the VMM creates virtio devices, it must allocate MMIO or PCI\r\n  and interrupt resources itself and then let the guest drivers know about them.\r\n  In other cases, like e.g. when a guest driver decides to reprogram a device,\r\n  the vm-allocator will only update its allocated resources map to match the\r\n  guest driven changes.\r\n  In any cases, the guest and the VMM views of the system resources should be\r\n  coherent.\r\n\r\n- When being asked by the VMM or the device emulation code, the vm-allocator\r\n  will either allocate and return a non overlapping set of resources or fail,\r\n  based on its coherent and full knowlege of the system resources map.\r\n\r\nThe `allocator` part in the `vm-allocator` name might be confusing as this crate\r\nbasically reserves and keeps track of resources on behalf of the guest. Naming is hard...\r\n\r\n### Resources\r\n\r\nBased on our collective (crosvm, Firecracker, cloud-hypervisor) experience and\r\nknowledge, I think we can group guest reesourcses in 3 categories:\r\n\r\n1. Address space resources: The `vm-allocator` needs to manage the guest address\r\n   spaces. In practice, all 3 above mentioned VMMs deal with 2 address spaces:\r\n   the PIO and MMIO ones. The `vm-allocator` should be responsible for reserving\r\n   and allocating address ranges from those address spaces. An address space\r\n   resource could thus be defined as:\r\n   ```Rust\r\n   pub struct Range(pub GuestAddress, pub GuestUsize);\r\n\r\n   pub enum AddressType {\r\n       PIO,\r\n       MMIO,\r\n   }\r\n\r\n   pub struct AddressResource {\r\n       type: AddressType,\r\n       range: Range,\r\n       alignment: GuestUsize\r\n   }\r\n   ```\r\n\r\n2. Interrupt resources: Another device related resource that the vm-allocator\r\n   has to manage are interrupts. Together with memory (PIO and MMIO), interrupts\r\n   entirely define a device resources.\r\n   Devices can trigger interrupts either by toggling physical lines or by\r\n   writing to specific memory locations. The former are legacy interrupts and\r\n   are defined through a system wide list of IRQ numbers also know as GSIs. The\r\n   latter are Message Signalled Interrupts (MSIs) and are defined by MSI vectors\r\n   that include a GSI and a memory address. Thus an interrupt resource could be\r\n   defined ad:\r\n   ```Rust\r\n   pub struct InterruptResource {\r\n       gsi: u32,\r\n       address: Option<AddressResource>,\r\n   }\r\n   ```\r\n\r\n   or:\r\n\r\n   ```Rust\r\n   pub struct LegacyInterruptResource {\r\n       gsi: u32,\r\n   }\r\n\r\n   pub struct MsiInterruptResource {\r\n       gsi: u32,\r\n       address: AddressResource,\r\n   }\r\n   ```\r\n   \r\n\r\n3. Id resources: The vm-allocator could also keep track of internal, guest\r\n   unique IDs for example to uniquely identify resources.\r\n\r\n\r\n#### Resource Traits\r\n\r\nI think the few resources types that we have to manage are too different to try\r\nto put them under the same interface or Trait. Moreover, serialization of those\r\nresources will be easier by not being Traits.\r\n\r\nInstead, I think it would make more sense to define resources as an `Enum`,\r\nbased on the above defined structures:\r\n\r\n```Rust\r\npub enum VmResource {\r\n    Address(AddressResource),\r\n    LegacyInterrupt(u32),\r\n    MsiInterrupt(u32, AddressResource),\r\n    Id(u32),\r\n}\r\n```\r\n\r\n### Resource allocators\r\n\r\nIt should be up to each VMM to decide which, how and how many of the above\r\ndescribed resources it wants to manage and allocate through the `vm-allocator`\r\ncrate. As such I believe it would make sense to define resource allocator traits\r\nfor each one of the above described resources: `AddressAllocator`, `LegacyInterruptAllocator`, etc.\r\n\r\nThe overall VMM allocator would be made of several resource allocators, and device\r\nemulation implementations would require a specific set of allocators depending on the resources\r\nthey'd need to allocate and update.\r\n\r\nFor example, a PCI device emulation creation API could request 2 `AddressAllocator`s (one PIO, one MMIO), and 1 `MsiInterruptAllocator`. \r\n\r\n## Device Manager\r\n\r\nThe current `vm-device` PR tightly couples the device model to the `vm-allocator`\r\ncrate, by passing a complete `SystemAllocator` to the `DeviceManager` creation\r\nAPI. The idea behind the current design is that the `DeviceManager` is responsible for\r\ndoing the resource allocations, and some concerns have been raised about that\r\napproach. It may make more sense to separate the device management from the\r\nresource management to give more flexibility to VMM implementations.\r\n\r\nAs a consequence, the `vm-allocator` and `vm-device` logical coupling could be\r\nmade a lot weaker by having the `DeviceManager` API only **consume** resources that have\r\nbeen allocated, reserved and updated somewhere else (typically by the VMM or the\r\ndevice emulation code).\r\n\r\nThe `DeviceManager` requirements is two-fold:\r\n\r\n1. Keep track of all registered devices and link them back to their resources.\r\n   We want to be able to have once central point of knowledge for the guest\r\n   devices and their associated resources.\r\n\r\n2. Handle all device IO. For each IO VM exit (PIO or MMIO), the `DeviceManager`\r\n   should be able to resolve the VM exit address back to a registered device.\r\n   It will then forward the VM exit data back to the device.\r\n\r\n### Device Trait\r\n\r\nDevice IO operations on a given bus can be represented by a simple `Device` or\r\n`BusDevice` trait:\r\n\r\n```Rust\r\npub trait Device: Send {\r\n    /// Get the device name.\r\n    fn name(&self) -> String;\r\n    /// Read from the guest physical address `addr` to `data`.\r\n    fn read(&mut self, addr: GuestAddress, data: &mut [u8], io_type: IoType);\r\n    /// Write `data` to the guest physical address `addr`.\r\n    fn write(&mut self, addr: GuestAddress, data: &[u8], io_type: IoType);\r\n```\r\n\r\n### IO Bus\r\n\r\nOne of the main requirement for the `DeviceManager` is to handle IO VM exits.\r\nIn practice, there are 2 kinds of IO VM exits: PIO and MMIO ones. Although we\r\ncould define a `Bus` trait, I believe that in practice we'd end up always\r\nhandling 2 of them and not more. For the sake of simplicity, it may make more\r\nsense to only define a `Bus` structure:\r\n\r\n```Rust\r\npub struct Bus {\r\n    devices: BTreeMap<Range, Arc<Mutex<dyn Device>>>,\r\n}\r\n```\r\n\r\nUsefulness of a `Bus` Trait to be discussed...\r\n\r\n### `DeviceManager` and `vm-allocator` relationship\r\n\r\nIn that updated design, the `DeviceManager` would no longer be responsible for\r\nallocating devices resources. Instead, it would be up to the main VMM code to\r\ndo so. The main VMM code would:\r\n\r\n1. Create all necessary devices.\r\n\r\n2. Allocate all device resources, be it directly or through the device creation\r\n   routines. Eventually, when creating a device, a VMM knows which resources\r\n   it can allocates up front.\r\n\r\n3. Register and unregister all created devices, with their related resources\r\n   allocated at device creation time.\r\n\r\nSome devices get their resources allocated or updated by the guest directly,\r\ne.g. for PCI MSIs or for PCI reprogramming. In those case, the `DeviceManager`\r\nAPI should be notified (by the device emulation code) about such changes.\r\n\r\n### `DeviceManager` API\r\n\r\nBased on all the above mentioned assumptions and proposals, the simplified\r\n`DeviceManager` API would look like:\r\n\r\n```Rust\r\nimpl DeviceManager {\r\n    /// Create a new `DeviceManager`\r\n    pub fn new() -> Self\r\n\r\n    /// Register a new device with its parent and resources.\r\n    pub fn register_device(\r\n        &mut self,\r\n        dev: Arc<Mutex<dyn Device>>,\r\n        parent: Option<Arc<Mutex<dyn Device>>>,\r\n        resources: &mut Vec<VmResource>,\r\n    ) -> Result<(u32)> {\r\n\r\n    /// Unregister a device from `DeviceManager`.\r\n    pub fn unregister_device(&mut self, instance_id: u32) -> Result<()> {\r\n\r\n    /// Update a device.\r\n    pub fn update_device(\r\n        &mut self,\r\n        instance_id: u32,\r\n        new_resources: &mut Vec<VmResource>,\r\n   )\r\n}\r\n```\r\n\r\nThe only potential dependencies between `vm-device` and `vm-allocator` would be\r\nthrough the `VmResource` definition.\r\nAs a consequence, a minimal VMM could decice to entirely avoid defining and\r\nusing resource allocators and still be able to use the DeviceManager API.\r\n\r\n@liujing2 @andreeaflorescu @jiangliu @sboeuf WDYT? Based on your experience, and if you think this looks like a simple enough, reasonable base to start from, let's try to describe what would prevent such proposal from being used in our VMMs.", "updated_at": "2019-08-04T13:22:21Z", "url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/comments/518003480", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-allocator/pull/1#issuecomment-518003480", "created_at": "2019-08-04T13:22:21Z", "id": 518003480, "node_id": "MDEyOklzc3VlQ29tbWVudDUxODAwMzQ4MA=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/1", "body": "\n\n> On Aug 4, 2019, at 9:22 PM, Samuel Ortiz <notifications@github.com <mailto:notifications@github.com>> wrote:\n> \n> It seems we're running a bit in circle between that PR and the vm-device\n> one <https://github.com/rust-vmm/vm-device/pull/3>.\n> \n> \nThanks for taking efforts to shoot this issue down.\nSeems one way to break the circle is to let:\n1) vm-allocator focus on managing(allocating and freeing) resources. \n2) vm-device implements methods to access/control resources allocated from vm-allocator.\nThe IRQ has caused us much trouble in previous discussions. With above policy, it gets simpler,\nvm-allocator only manages IRQ numbers, and vm-device implements legacy IRQ/MSI objects for IRQ numbers allocated from vm-allocator.\n> I'd like to use this PR to discuss about an updated design.\n> \n> vm-allocator\n> \n> The vm-allocator crate is managing guest resources, mainly related to devices.\n> When the VMM is responsible for directly reseving and exposing resources to a\n> guest, the vm-allocator crate allocates, reserves and manages resources. Its\n> main requirements are:\n> \n> Keep track of a guest's reserved and allocated resources. In some cases, the\n> vm-allocator will allocate and expose resources for a guest to consume, while\n> in others it only keeps track of resources that are allocated from the guest.\n> For example, when the VMM creates virtio devices, it must allocate MMIO or PCI\n> and interrupt resources itself and then let the guest drivers know about them.\n> In other cases, like e.g. when a guest driver decides to reprogram a device,\n> the vm-allocator will only update its allocated resources map to match the\n> guest driven changes.\n> In any cases, the guest and the VMM views of the system resources should be\n> coherent.\n> \n> When being asked by the VMM or the device emulation code, the vm-allocator\n> will either allocate and return a non overlapping set of resources or fail,\n> based on its coherent and full knowlege of the system resources map.\n> \n> The allocator part in the vm-allocator name might be confusing as this crate\n> basically reserves and keeps track of resources on behalf of the guest. Naming is hard\u2026\n> \nVm-resources or vmm-resource-manager?\n> Resources\n> \n> Based on our collective (crosvm, Firecracker, cloud-hypervisor) experience and\n> knowledge, I think we can group guest reesourcses in 3 categories:\n> \n> Address space resources: The vm-allocator needs to manage the guest address\n> spaces. In practice, all 3 above mentioned VMMs deal with 2 address spaces:\n> the PIO and MMIO ones. The vm-allocator should be responsible for reserving\n> and allocating address ranges from those address spaces. An address space\n> resource could thus be defined as:\n> \n> pub struct Range(pub GuestAddress, pub GuestUsize);\n> \n> pub enum AddressType {\n>     PIO,\n>     MMIO,\n> }\n> \n> pub struct AddressResource {\n>     type: AddressType,\n>     range: Range,\n>     alignment: GuestUsize\n> }\n> Interrupt resources: Another device related resource that the vm-allocator\n> has to manage are interrupts. Together with memory (PIO and MMIO), interrupts\n> entirely define a device resources.\n> Devices can trigger interrupts either by toggling physical lines or by\n> writing to specific memory locations. The former are legacy interrupts and\n> are defined through a system wide list of IRQ numbers also know as GSIs. The\n> latter are Message Signalled Interrupts (MSIs) and are defined by MSI vectors\n> that include a GSI and a memory address. Thus an interrupt resource could be\n> defined ad:\n> \n> pub struct InterruptResource {\n>     gsi: u32,\n>     address: Option<AddressResource>,\n> }\n> or:\n> \n> pub struct LegacyInterruptResource {\n>     gsi: u32,\n> }\n> \n> pub struct MsiInterruptResource {\n>     gsi: u32,\n>     address: AddressResource,\n> }\nI have some different ideas here.\n1) in vm-allocator, \npub struct InterruptResource(u32);\n\n2) in vm-device,\npub  trait InterruptSource {\n\tfn trigger(source: u32);\n        fn ack(source: u32);\n        fn mask();\n        fn unmask();\n\t\u2026.\n} \n\npub struct MsiIrqManager {\n        address: AddressResource,\n\tvmfd: KvmVmFd( or RawFd),\n}\n\nImpl MsiIrqManager {\n   fn new(address: AddressResource) -> MsiIrqManager {\u2026}\n   fn create_irq(irq: InterruptResource) -> MsiInterruptSource {\u2026}\n}\n\npub struct MsiInterruptSource {\n     irq: InterruptResource,\n     irqfd: RawFd,\n     mgr: Arc<MsiIrqManager>\n}\n\nimpl InterruptSource for MsiInterruptSource {\n}\n\npub struct LegacyInterruptSource {\n     irq: InterruptResource,\n     status: Atomic<u32>,\n     irqfd: RawFd,\n     eventfd: RawFd,\n}\n\nimpl InterruptSource for LegacyInterruptSource {\n}\n> \n> Id resources: The vm-allocator could also keep track of internal, guest\n> unique IDs for example to uniquely identify resources.\n> \n> Resource Traits\n> \n> I think the few resources types that we have to manage are too different to try\n> to put them under the same interface or Trait. Moreover, serialization of those\n> resources will be easier by not being Traits.\n> \n> Instead, I think it would make more sense to define resources as an Enum,\n> based on the above defined structures:\n> \n> pub enum VmResource {\n>     Address(AddressResource),\n>     LegacyInterrupt(u32),\n>     MsiInterrupt(u32, AddressResource),\nSuggest to merge LegacyInterrupt and MsiInterrupt:)\n>     Id(u32),\n> }\n> Resource allocators\n> \n> It should be up to each VMM to decide which, how and how many of the above\n> described resources it wants to manage and allocate through the vm-allocator\n> crate. As such I believe it would make sense to define resource allocator traits\n> for each one of the above described resources: AddressAllocator, LegacyInterruptAllocator, etc.\n> \n> The overall VMM allocator would be made of several resource allocators, and device\n> emulation implementations would require a specific set of allocators depending on the resources\n> they'd need to allocate and update.\n> \n> For example, a PCI device emulation creation API could request 2 AddressAllocators (one PIO, one MMIO), and 1 MsiInterruptAllocator.\n> \n> Device Manager\n> \n> The current vm-device PR tightly couples the device model to the vm-allocator\n> crate, by passing a complete SystemAllocator to the DeviceManager creation\n> API. The idea behind the current design is that the DeviceManager is responsible for\n> doing the resource allocations, and some concerns have been raised about that\n> approach. It may make more sense to separate the device management from the\n> resource management to give more flexibility to VMM implementations.\n> \n> As a consequence, the vm-allocator and vm-device logical coupling could be\n> made a lot weaker by having the DeviceManager API only consume resources that have\n> been allocated, reserved and updated somewhere else (typically by the VMM or the\n> device emulation code).\n> \n> The DeviceManager requirements is two-fold:\n> \n> Keep track of all registered devices and link them back to their resources.\n> We want to be able to have once central point of knowledge for the guest\n> devices and their associated resources.\n> \n> Handle all device IO. For each IO VM exit (PIO or MMIO), the DeviceManager\n> should be able to resolve the VM exit address back to a registered device.\n> It will then forward the VM exit data back to the device.\n> \n> Device Trait\n> \n> Device IO operations on a given bus can be represented by a simple Device or\n> BusDevice trait:\n> \n> pub trait Device: Send {\n>     /// Get the device name.\n>     fn name(&self) -> String;\n>     /// Read from the guest physical address `addr` to `data`.\n>     fn read(&mut self, addr: GuestAddress, data: &mut [u8], io_type: IoType);\n>     /// Write `data` to the guest physical address `addr`.\n>     fn write(&mut self, addr: GuestAddress, data: &[u8], io_type: IoType);\n> IO Bus\n> \n> One of the main requirement for the DeviceManager is to handle IO VM exits.\n> In practice, there are 2 kinds of IO VM exits: PIO and MMIO ones. Although we\n> could define a Bus trait, I believe that in practice we'd end up always\n> handling 2 of them and not more. For the sake of simplicity, it may make more\n> sense to only define a Bus structure:\n> \n> pub struct Bus {\n>     devices: BTreeMap<Range, Arc<Mutex<dyn Device>>>,\n> }\nSuggest using devices: BTreeMap<Range, Arc<dyn Device>>, the Device Trait objects make decisions about how to themselves from concurrent access.\n\n> Usefulness of a Bus Trait to be discussed...\n> \n> DeviceManager and vm-allocator relationship\n> \n> In that updated design, the DeviceManager would no longer be responsible for\n> allocating devices resources. Instead, it would be up to the main VMM code to\n> do so. The main VMM code would:\n> \n> Create all necessary devices.\n> \n> Allocate all device resources, be it directly or through the device creation\n> routines. Eventually, when creating a device, a VMM knows which resources\n> it can allocates up front.\n> \n> Register and unregister all created devices, with their related resources\n> allocated at device creation time.\n> \n> Some devices get their resources allocated or updated by the guest directly,\n> e.g. for PCI MSIs or for PCI reprogramming. In those case, the DeviceManager\n> API should be notified (by the device emulation code) about such changes.\n> \nWe need to specify the way for device objects to notify device managers, it may get hard to implement when taking rust ownership and crate dependencies into account.\n\n> DeviceManager API\n> \n> Based on all the above mentioned assumptions and proposals, the simplified\n> DeviceManager API would look like:\n> \n> impl DeviceManager {\n>     /// Create a new `DeviceManager`\n>     pub fn new() -> Self\n> \n>     /// Register a new device with its parent and resources.\n>     pub fn register_device(\n>         &mut self,\n>         dev: Arc<Mutex<dyn Device>>,\n>         parent: Option<Arc<Mutex<dyn Device>>>,\n>         resources: &mut Vec<VmResource>,\n>     ) -> Result<(u32)> {\n> \n>     /// Unregister a device from `DeviceManager`.\n>     pub fn unregister_device(&mut self, instance_id: u32) -> Result<()> {\n> \n>     /// Update a device.\n>     pub fn update_device(\n>         &mut self,\n>         instance_id: u32,\n>         new_resources: &mut Vec<VmResource>,\n>    )\n> }\nStill not clear about the way to make use of the update_device() interface.\nLet imagine the flow to reprogram a PCI bar.\n1) guest writes to the bar register in PCI configuration space\n2) guest traps into VMM\n3) the device driver figures out it\u2019s a PCI reprogram request\n4) the device driver needs to reallocate/reserve the MMIO resource configured by the guest OS. Essentially the device driver needs to call into the device manager/vmm/resource allocator. But the ownership hierarchy is:\nVmm ----> vm_allocator\n         |---> device_manager \u2014> device_object\nSo we need to provide a way for the device_object to call into the vm_allocator. \nThis issue has troubled me for a long time:(\n> The only potential dependencies between vm-device and vm-allocator would be\n> through the VmResource definition.\n> As a consequence, a minimal VMM could decice to entirely avoid defining and\n> using resource allocators and still be able to use the DeviceManager API.\n> \n> @liujing2 <https://github.com/liujing2> @andreeaflorescu <https://github.com/andreeaflorescu> @jiangliu <https://github.com/jiangliu> @sboeuf <https://github.com/sboeuf> WDYT? Based on your experience, and if you think this looks like a simple enough, reasonable base to start from, let's try to describe what would prevent such proposal from being used in our VMMs.\n> \n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub <https://github.com/rust-vmm/vm-allocator/pull/1?email_source=notifications&email_token=AAOXR7BXO352KW32Y34HSTLQC3JY3A5CNFSM4IHY7YG2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOD3QBWGA#issuecomment-518003480>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAOXR7DQDR7SLVEAJ74IASLQC3JY3ANCNFSM4IHY7YGQ>.\n> \n\n", "updated_at": "2019-08-04T15:00:26Z", "url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/comments/518010655", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-allocator/pull/1#issuecomment-518010655", "created_at": "2019-08-04T15:00:26Z", "id": 518010655, "node_id": "MDEyOklzc3VlQ29tbWVudDUxODAxMDY1NQ=="}, {"user": {"following_url": "https://api.github.com/users/liujing2/following{/other_user}", "url": "https://api.github.com/users/liujing2", "site_admin": false, "gists_url": "https://api.github.com/users/liujing2/gists{/gist_id}", "node_id": "MDQ6VXNlcjM5Njg0NjQ5", "starred_url": "https://api.github.com/users/liujing2/starred{/owner}{/repo}", "gravatar_id": "", "id": 39684649, "events_url": "https://api.github.com/users/liujing2/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/39684649?v=4", "login": "liujing2", "repos_url": "https://api.github.com/users/liujing2/repos", "subscriptions_url": "https://api.github.com/users/liujing2/subscriptions", "followers_url": "https://api.github.com/users/liujing2/followers", "html_url": "https://github.com/liujing2", "received_events_url": "https://api.github.com/users/liujing2/received_events", "type": "User", "organizations_url": "https://api.github.com/users/liujing2/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/1", "body": "@sameo Thank you for the detailed clarification!\r\nBesides @jiangliu 's interrupt management idea posted on https://github.com/rust-vmm/vm-device/pull/6, I feel good to both the proposal.  ", "updated_at": "2019-08-08T07:37:46Z", "url": "https://api.github.com/repos/rust-vmm/vm-allocator/issues/comments/519405365", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-allocator/pull/1#issuecomment-519405365", "created_at": "2019-08-08T07:37:46Z", "id": 519405365, "node_id": "MDEyOklzc3VlQ29tbWVudDUxOTQwNTM2NQ=="}]