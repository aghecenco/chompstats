[{"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "I like the idea of exposing a simple hypervisor-agnostic API that can start as just \"pub use\" and can later migrate to marshaling/unmarshaling between hypervisor-specific and structs and generic ones.\r\n\r\nI think we should have fine-grained traits and make it possible to compile them out.", "updated_at": "2019-03-18T17:23:30Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/474017843", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-474017843", "created_at": "2019-03-18T17:23:30Z", "id": 474017843, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDAxNzg0Mw=="}, {"user": {"following_url": "https://api.github.com/users/jennymankin/following{/other_user}", "url": "https://api.github.com/users/jennymankin", "site_admin": false, "gists_url": "https://api.github.com/users/jennymankin/gists{/gist_id}", "node_id": "MDQ6VXNlcjQ0ODc3NTQy", "starred_url": "https://api.github.com/users/jennymankin/starred{/owner}{/repo}", "gravatar_id": "", "id": 44877542, "events_url": "https://api.github.com/users/jennymankin/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/44877542?v=4", "login": "jennymankin", "repos_url": "https://api.github.com/users/jennymankin/repos", "subscriptions_url": "https://api.github.com/users/jennymankin/subscriptions", "followers_url": "https://api.github.com/users/jennymankin/followers", "html_url": "https://github.com/jennymankin", "received_events_url": "https://api.github.com/users/jennymankin/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jennymankin/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "Thank you for the feedback. I like your suggestion on conditional-compilation of fine-grained traits between hypervisor versions. \r\n\r\nRegarding your point on \"pub use\", are you referring to the use of \"pub use\" to expose data structures in the design document example above? (That is, with kvm_binding data structures exposed via \"pub use\", and kvm-related code using the data structures directly and WHP/other hypervisors taking the exposed structures and marshalling them manually?) Or should there be a third generic struct, and in addition to WHP marshalling data, the KVM APIs would also marshall data to and from this generic struct into the kvm_bindings structs? (Or some other suggestion that I'm missing?)", "updated_at": "2019-03-19T01:29:04Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/474162584", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-474162584", "created_at": "2019-03-19T01:29:04Z", "id": 474162584, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDE2MjU4NA=="}, {"user": {"following_url": "https://api.github.com/users/yisun-git/following{/other_user}", "url": "https://api.github.com/users/yisun-git", "site_admin": false, "gists_url": "https://api.github.com/users/yisun-git/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODgwMTQx", "starred_url": "https://api.github.com/users/yisun-git/starred{/owner}{/repo}", "gravatar_id": "", "id": 22880141, "events_url": "https://api.github.com/users/yisun-git/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/22880141?v=4", "login": "yisun-git", "repos_url": "https://api.github.com/users/yisun-git/repos", "subscriptions_url": "https://api.github.com/users/yisun-git/subscriptions", "followers_url": "https://api.github.com/users/yisun-git/followers", "html_url": "https://github.com/yisun-git", "received_events_url": "https://api.github.com/users/yisun-git/received_events", "type": "User", "organizations_url": "https://api.github.com/users/yisun-git/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "As what I replied to Paolo in rust-vmm mail list, I have similar idea as yours to implement hypervisor agnostic vcpu framework. My idea is to abstract a \"hypervisor\" trait and implement it for KVM/HyperV/etc. Vcpu calls the common interfaces. Based on that, I will implement hypervisor agnostic cpu-model to support customized cpu models.\r\n\r\nAs our ideas are similar, I think we can work together to make things better. I noticed you already had Rust Hyper-V crate libwhp. Do you mainly work for Hyper-V? Do you have plan to implement KVM too? If no, I may help to implement KVM part.", "updated_at": "2019-03-19T06:15:11Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/474207178", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-474207178", "created_at": "2019-03-19T05:50:07Z", "id": 474207178, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDIwNzE3OA=="}, {"user": {"following_url": "https://api.github.com/users/jennymankin/following{/other_user}", "url": "https://api.github.com/users/jennymankin", "site_admin": false, "gists_url": "https://api.github.com/users/jennymankin/gists{/gist_id}", "node_id": "MDQ6VXNlcjQ0ODc3NTQy", "starred_url": "https://api.github.com/users/jennymankin/starred{/owner}{/repo}", "gravatar_id": "", "id": 44877542, "events_url": "https://api.github.com/users/jennymankin/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/44877542?v=4", "login": "jennymankin", "repos_url": "https://api.github.com/users/jennymankin/repos", "subscriptions_url": "https://api.github.com/users/jennymankin/subscriptions", "followers_url": "https://api.github.com/users/jennymankin/followers", "html_url": "https://github.com/jennymankin", "received_events_url": "https://api.github.com/users/jennymankin/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jennymankin/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "Hi @yisun-git , I agree, the ideas are similar so it would be great to work together. I am interested in understanding more about your proposed implementation, particularly if it would provide a more natural approach.  The modular design I envision would have a VMM crate calling the (abstracted) functions of the VCPU trait (rather than the other way around), but perhaps I am also stuck on what a VMM crate would look like based on existing VMM crates in Firecracker/crosvm (and based on our example Hyper-V implementation for libwhp).  As you intuited in your email reply, one of our explicit goals is to minimize the refactoring that would be required for existing VMMs/container solutions like Firecracker/crosvm.\r\n\r\nAs you develop them, seeing more design details and/or example trait definitions for your VMM/CPU crates would, I think, definitely help us to understand your approach, as well as to help us evaluate the tradeoffs of both approaches as we move forward.\r\n\r\nWe do work mainly with Hyper-V, so it would indeed be nice to have your help in implementing the KVM part.", "updated_at": "2019-03-20T02:03:22Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/474654522", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-474654522", "created_at": "2019-03-20T02:03:22Z", "id": 474654522, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NDY1NDUyMg=="}, {"user": {"following_url": "https://api.github.com/users/yisun-git/following{/other_user}", "url": "https://api.github.com/users/yisun-git", "site_admin": false, "gists_url": "https://api.github.com/users/yisun-git/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODgwMTQx", "starred_url": "https://api.github.com/users/yisun-git/starred{/owner}{/repo}", "gravatar_id": "", "id": 22880141, "events_url": "https://api.github.com/users/yisun-git/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/22880141?v=4", "login": "yisun-git", "repos_url": "https://api.github.com/users/yisun-git/repos", "subscriptions_url": "https://api.github.com/users/yisun-git/subscriptions", "followers_url": "https://api.github.com/users/yisun-git/followers", "html_url": "https://github.com/yisun-git", "received_events_url": "https://api.github.com/users/yisun-git/received_events", "type": "User", "organizations_url": "https://api.github.com/users/yisun-git/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "Sorry for late. I am just back from vacation.\r\n\r\nPer my thought, our idea is to make hypervisor agnostic so we should abstract a hypervisor trait directly. It provides common functions, e.g. get_msr/set_msr/set_cpuid/etc. The specific hypervisor implementations, e.g. kvm/hyper-v/etc, are behind it. Then, the vcpu calls the functions in hypervisor trait. This needs the changes in vmm/vcpu/etc to replace kvm functions to hypervisor functions. But I think the changes should not be too many.\r\n\r\nI am glad to implement KVM part. Looking forward to work with you together. :)\r\n\r\n", "updated_at": "2019-03-27T02:34:56Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/476942137", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-476942137", "created_at": "2019-03-27T02:34:56Z", "id": 476942137, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3Njk0MjEzNw=="}, {"user": {"following_url": "https://api.github.com/users/jennymankin/following{/other_user}", "url": "https://api.github.com/users/jennymankin", "site_admin": false, "gists_url": "https://api.github.com/users/jennymankin/gists{/gist_id}", "node_id": "MDQ6VXNlcjQ0ODc3NTQy", "starred_url": "https://api.github.com/users/jennymankin/starred{/owner}{/repo}", "gravatar_id": "", "id": 44877542, "events_url": "https://api.github.com/users/jennymankin/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/44877542?v=4", "login": "jennymankin", "repos_url": "https://api.github.com/users/jennymankin/repos", "subscriptions_url": "https://api.github.com/users/jennymankin/subscriptions", "followers_url": "https://api.github.com/users/jennymankin/followers", "html_url": "https://github.com/jennymankin", "received_events_url": "https://api.github.com/users/jennymankin/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jennymankin/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "## Update to design\r\n\r\nFor the trait definition, I pull all the functions currently in the kvm-ioctl's crate, since these are key functions and both KVM and Windows Hypervisor Platform (WHP) provide underlying APIs that can be used to implement each of these function. The trait is below; there is not much change from the original proposal, just some refinement as I've now done basic POC work on each for both WHP and kvm-ioctls (the former being the more work, given that the signatures were almost uniformly taken from kvm-ioctls).\r\n\r\n```\r\npub trait Vcpu {\r\n    type RunContextType;\r\n    fn get_regs(&self) -> Result<VmmRegisters>;\r\n    fn set_regs(&self, regs: &VmmRegisters) -> Result<()>;\r\n    fn get_sregs(&self) -> Result<SpecialRegisters>;\r\n    fn set_sregs(&self, sregs: &SpecialRegisters) -> Result<()>;\r\n    fn get_fpu(&self) -> Result<Fpu>;\r\n    fn set_fpu(&self, fpu: &Fpu) -> Result<()>;\r\n    fn set_cpuid2(&self, cpuid: &CpuId) -> Result<()>;\r\n    fn get_lapic(&self) -> Result<LApicState>;\r\n    fn set_lapic(&self, klapic: &LApicState) -> Result<()>;\r\n    fn get_msrs(&self, msrs: &mut MsrEntries) -> Result<(i32)>;\r\n    fn set_msrs(&self, msrs: &MsrEntries) -> Result<()>;\r\n    fn run(&self) -> Result<VcpuExit>;\r\n    fn get_run_context(&self) -> Self::RunContextType;\r\n}\r\n```\r\nSome questions for the rust-vmm community:\r\n\r\n### Additional Vcpu functions\r\n\r\nIn additional to these functions pulled from kvm-ioctls, there are additional Vcpu functions that could be useful to include as well, based on the larger set provided by WHP and KVM and implemented by libwhp and crosvm (respectively) (Firecracker Vcpu functions are already fully represented). There are two options: \r\n\t1. Include these in the Vcpu trait, and any hypervisors not implementing these functions could opt-out using (for example) the unimplemented!(); macro. Eg, get/set MP state, get/set xsave state, etc.\r\n\t2.  Keep only this smaller subset for now, and any Vcpus that want to implement additional functions can do so alongside the `impl Vcpu` trait implementation.\r\n\t\r\n### Arch-independence\r\n\r\nAll of the functions above (except for run/get_run_context) are conditionally-compiled for x86/x64 in their previous forms (crosvm, Firecracker, kvm-ioctls). The same conditional compilation can be applied here in the traits. It doesn't leave a lot of ARM functionality implemented, but I assume that can be added later (and similarly blocked with conditional compilation) as needed for that use case.\r\n\t\r\n### Home of reference implementations\r\n\r\nWhere should reference implementations of these traits live? Obviously kvm-ioctls is a good location for the KVM-based implementation of these traits; as shown in the design above, there is little code refactoring required to make this change. Currently our libwhp implementation (which provides Rust bindings/examples) for Hyper-V lives in a [different github space](https://github.com/insula-rs/libwhp). It probably makes sense to keep that library there, and make changes there to implement these traits, unless the rust-vmm community here, and the other libwhp developers think the implementation belongs more in the rust-vmm repo.\r\n\r\n*****\r\n\r\n@yisun-git, I am particularly interested in your feedback on the design here, and whether this is the set of common functions you also had in mind, or whether you'd like to see more. From your last comment, I think it sounds like we are on the same page as to what this Vcpu trait should provide, though you're calling it a VMM trait and I'm limiting it here to a Vcpu (where the Vcpu traits could then be used as a building block for a later VMM crate). I'm still tryin got understand whether we envision using the traits in the same way. Given my description of the changes to kvm-ioctls and WHP in the original issue statement above, as well as my description of the use of such a vcpu function in my proposal for the `arch` crate [here](https://github.com/rust-vmm/community/issues/41), is this what you also had in mind or do you see the trait implementations being done differently?\r\n", "updated_at": "2019-04-08T04:34:59Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/480680171", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-480680171", "created_at": "2019-04-08T04:34:59Z", "id": 480680171, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDY4MDE3MQ=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "LGTM.", "updated_at": "2019-04-08T10:32:49Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/480777186", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-480777186", "created_at": "2019-04-08T10:32:49Z", "id": 480777186, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDc3NzE4Ng=="}, {"user": {"following_url": "https://api.github.com/users/yisun-git/following{/other_user}", "url": "https://api.github.com/users/yisun-git", "site_admin": false, "gists_url": "https://api.github.com/users/yisun-git/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODgwMTQx", "starred_url": "https://api.github.com/users/yisun-git/starred{/owner}{/repo}", "gravatar_id": "", "id": 22880141, "events_url": "https://api.github.com/users/yisun-git/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/22880141?v=4", "login": "yisun-git", "repos_url": "https://api.github.com/users/yisun-git/repos", "subscriptions_url": "https://api.github.com/users/yisun-git/subscriptions", "followers_url": "https://api.github.com/users/yisun-git/followers", "html_url": "https://github.com/yisun-git", "received_events_url": "https://api.github.com/users/yisun-git/received_events", "type": "User", "organizations_url": "https://api.github.com/users/yisun-git/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/40", "body": "@jennymankin , I just left a message to you on slack. I added an issue on vmm-vcpu crate and present my ideas. Please check it when you are free. :)", "updated_at": "2019-04-18T08:29:06Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/484406021", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/40#issuecomment-484406021", "created_at": "2019-04-18T08:29:06Z", "id": 484406021, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4NDQwNjAyMQ=="}]