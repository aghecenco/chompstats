[{"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "I'm a bit wary of adding something like `VirtioDeviceInterrupt` here, it seems like a generic trait that should be in `vm-device`. What is the state there? Should we start that crate by just adding\r\n\r\n```\r\n// not sure why Sized + Send in @jiangliu's patch\r\npub trait ConsumeInterrupt {\r\n    /// Inject the specified interrupt into the guest.\r\n    fn trigger(&self, interrupt_id: u32) -> std::io::Error;\r\n}\r\n\r\nimpl ConsumeInterrupt for EventFd {\r\n    fn trigger(&self, interrupt_id: u32) {\r\n        self.write(1);\r\n    }\r\n}\r\n\r\nimpl ConsumeInterrupt for Vec<EventFd> {\r\n    fn trigger(&self, interrupt_id: u32) {\r\n        self[interrupt_id].trigger(0);\r\n    }\r\n}\r\n```\r\n\r\n?", "updated_at": "2019-06-05T13:14:32Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499077725", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499077725", "created_at": "2019-06-05T13:14:32Z", "id": 499077725, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTA3NzcyNQ=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> I'm a bit wary of adding something like `VirtioDeviceInterrupt` here, it seems like a generic trait that should be in `vm-device`. What is the state there? Should we start that crate by just adding\r\n> \r\n> ```\r\n> // not sure why Sized + Send in @jiangliu's patch\r\n> pub trait ConsumeInterrupt {\r\n>     /// Inject the specified interrupt into the guest.\r\n>     fn trigger(&self, interrupt_id: u32) -> std::io::Error;\r\n> }\r\n> \r\n> impl ConsumeInterrupt for EventFd {\r\n>     fn trigger(&self, interrupt_id: u32) {\r\n>         self.write(1);\r\n>     }\r\n> }\r\n> \r\n> impl ConsumeInterrupt for Vec<EventFd> {\r\n>     fn trigger(&self, interrupt_id: u32) {\r\n>         self[interrupt_id].trigger(0);\r\n>     }\r\n> }\r\n> ```\r\n> \r\n> ?\r\n\r\nThe VirtioDeviceInterrupt will have concrete implementations for both legacy irq and PCI MSI. For legacy IRQ, it need to set status bits into the interrupt status register before writing to the eventfd. So we can't simple implement ConsumeInterrupt trait for EventFd/Vec<EventFd>.\r\n\r\nAnd it's a good point that the VirtioDeviceInterrupt should be renamed and moved into the vm-device, there's no special treatment for VirtioDevice at all.\r\n\r\nThe Sized + Send may be an over-claim:(\r\n", "updated_at": "2019-06-05T13:25:29Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499081581", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499081581", "created_at": "2019-06-05T13:25:03Z", "id": 499081581, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTA4MTU4MQ=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> I'm a bit wary of adding something like `VirtioDeviceInterrupt` here, it seems like a generic trait that should be in `vm-device`. What is the state there? \r\n> \r\n\r\nI agree, and this is exactly what we're currently talking about here: https://github.com/intel/cloud-hypervisor/pull/38#discussion_r290713999 , also for adding MSI-X support to cloud-hypervisor.\r\n\r\nA generic trait makes sense to me, and it should indeed be part of the `vm-device` crate.\r\nAs for the latter, there's a PR currently pending for it, feel free to chime in so that we can pile this kind of addition on top of the initial PR once merged.", "updated_at": "2019-06-05T13:50:21Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499088817", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499088817", "created_at": "2019-06-05T13:44:19Z", "id": 499088817, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTA4ODgxNw=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "Seems I should review the vm-device crate first:)\r\nIt's a good point to let the vm-device crate to handle interrupts.", "updated_at": "2019-06-05T13:49:02Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499090595", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499090595", "created_at": "2019-06-05T13:49:02Z", "id": 499090595, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTA5MDU5NQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> For legacy IRQ, it need to set status bits into the interrupt status register before writing to the eventfd.\r\n\r\nThat should be handled by the PCI transport. The PCI transport should provide its own implementation of ConsumeInterrupt, with code like \"if !self.msi_active { self.set_interrupt_status(); } interrupt_controller.trigger(interrupt_id);\" where interrupt_controller is also a `ConsumeInterrupt` implementor, probably provided by the PCI bus, which in turn will percolate all the way down to `Vec<Eventfd>` or something that invokes the `KVM_SIGNAL_MSI` ioctl.", "updated_at": "2019-06-05T14:06:10Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499097628", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499097628", "created_at": "2019-06-05T14:06:10Z", "id": 499097628, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTA5NzYyOA=="}, {"user": {"following_url": "https://api.github.com/users/sboeuf/following{/other_user}", "url": "https://api.github.com/users/sboeuf", "site_admin": false, "gists_url": "https://api.github.com/users/sboeuf/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODkwNDEz", "starred_url": "https://api.github.com/users/sboeuf/starred{/owner}{/repo}", "gravatar_id": "", "id": 22890413, "events_url": "https://api.github.com/users/sboeuf/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/22890413?v=4", "login": "sboeuf", "repos_url": "https://api.github.com/users/sboeuf/repos", "subscriptions_url": "https://api.github.com/users/sboeuf/subscriptions", "followers_url": "https://api.github.com/users/sboeuf/followers", "html_url": "https://github.com/sboeuf", "received_events_url": "https://api.github.com/users/sboeuf/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sboeuf/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "@bonzini I feel we need two levels here since we want to keep the KVM specific bits at the vmm code level, while in between at the PCI level, we need to make a difference between IRQ and MSI.\r\nI'm sure what I'm trying to say is not very clear but take a look [here](https://github.com/intel/cloud-hypervisor/pull/38) for more details.", "updated_at": "2019-06-05T14:14:36Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499101209", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499101209", "created_at": "2019-06-05T14:14:36Z", "id": 499101209, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTEwMTIwOQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> I feel we need two levels here since we want to keep the KVM specific bits at the vmm code level, while in between at the PCI level, we need to make a difference between IRQ and MSI.\r\n\r\nRight, a trait gives you all the levels you need, for example:\r\n\r\n* virtio devices just see `ConsumeInterrupt`\r\n\r\n* virtio-pci devices provide an implementation that distinguishes between IRQ and MSI\r\n\r\n* the PCI bus provides two implementations, one for IRQ and one for MSI\r\n\r\n* the VMM uses the closure mechanism you have in intel/cloud-hypervisor#38 to invoke KVM ioctls or write to eventfds", "updated_at": "2019-06-05T14:19:50Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499103456", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499103456", "created_at": "2019-06-05T14:19:50Z", "id": 499103456, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTEwMzQ1Ng=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> > For legacy IRQ, it need to set status bits into the interrupt status register before writing to the eventfd.\r\n> \r\n> That should be handled by the PCI transport. The PCI transport should provide its own implementation of ConsumeInterrupt, with code like \"if !self.msi_active { self.set_interrupt_status(); } interrupt_controller.trigger(interrupt_id);\" where interrupt_controller is also a `ConsumeInterrupt` implementor, probably provided by the PCI bus, which in turn will percolate all the way down to `Vec<Eventfd>` or something that invokes the `KVM_SIGNAL_MSI` ioctl.\r\n\r\nGood point. Originally I planned to share code to deal with legacy IRQs between the PCI and MMIO transport layer.", "updated_at": "2019-06-05T14:20:06Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499103568", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499103568", "created_at": "2019-06-05T14:20:06Z", "id": 499103568, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTEwMzU2OA=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> > I feel we need two levels here since we want to keep the KVM specific bits at the vmm code level, while in between at the PCI level, we need to make a difference between IRQ and MSI.\r\n> \r\n> Right, a trait gives you all the levels you need, for example:\r\n> \r\n> * virtio devices just see `ConsumeInterrupt`\r\n> * virtio-pci devices provide an implementation that distinguishes between IRQ and MSI\r\n> * the PCI bus provides two implementations, one for IRQ and one for MSI\r\n> * the VMM uses the closure mechanism you have in [intel/cloud-hypervisor#38](https://github.com/intel/cloud-hypervisor/pull/38) to invoke KVM ioctls or write to eventfds\r\n\r\nI like the idea of cascaded ConsumeInterrupt, it gives us chances to play magic:)", "updated_at": "2019-06-05T14:22:30Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499104584", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499104584", "created_at": "2019-06-05T14:22:30Z", "id": 499104584, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTEwNDU4NA=="}, {"user": {"following_url": "https://api.github.com/users/sboeuf/following{/other_user}", "url": "https://api.github.com/users/sboeuf", "site_admin": false, "gists_url": "https://api.github.com/users/sboeuf/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODkwNDEz", "starred_url": "https://api.github.com/users/sboeuf/starred{/owner}{/repo}", "gravatar_id": "", "id": 22890413, "events_url": "https://api.github.com/users/sboeuf/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/22890413?v=4", "login": "sboeuf", "repos_url": "https://api.github.com/users/sboeuf/repos", "subscriptions_url": "https://api.github.com/users/sboeuf/subscriptions", "followers_url": "https://api.github.com/users/sboeuf/followers", "html_url": "https://github.com/sboeuf", "received_events_url": "https://api.github.com/users/sboeuf/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sboeuf/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "@bonzini ok I'm really trying to understand :)\r\n\r\n> virtio devices just see ConsumeInterrupt\r\n\r\nRight now, the `EventFd`, or the callback, is passed through `VirtioDevice.activate()`, how does that work with `ConsumeInterrupt`? What type of object would you pass to `VirtioDevice` so that later on, `VirtioDevice` can call into `object.trigger()` because the object implements `ConsumeInterrupt`?\r\n\r\n> virtio-pci devices provide an implementation that distinguishes between IRQ and MSI\r\n\r\nAre you suggesting something like:\r\n```rust\r\nimpl ConsumeInterrupt for VirtioPciDevice {\r\n        fn trigger() {\r\n                ...\r\n        }\r\n}\r\n```\r\nBut we're not supposed to pass the `VirtioPciDevice` down to the `VirtioDevice`, so who would call into this implementation?\r\n\r\n> the PCI bus provides two implementations, one for IRQ and one for MSI\r\n\r\n`PciDevice` is a trait. Are you suggesting that `PciDevice` could also implement `ConsumeInterrupt` with some default implementation?\r\n\r\n> the VMM uses the closure mechanism you have in intel/cloud-hypervisor#38 to invoke KVM ioctls or write to eventfds\r\n\r\nOk cool!\r\n", "updated_at": "2019-06-05T15:09:03Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499124632", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499124632", "created_at": "2019-06-05T15:09:03Z", "id": 499124632, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTEyNDYzMg=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "\n\n> On Jun 5, 2019, at 11:09 PM, Sebastien Boeuf <notifications@github.com <mailto:notifications@github.com>> wrote:\n> \n> @bonzini <https://github.com/bonzini> ok I'm really trying to understand :)\n> \n> virtio devices just see ConsumeInterrupt\n> \n> Right now, the EventFd, or the callback, is passed through VirtioDevice.activate(), how does that work with ConsumeInterrupt? What type of object would you pass to VirtioDevice so that later on, VirtioDevice can call into object.trigger() because the object implements ConsumeInterrupt?\n> \n> virtio-pci devices provide an implementation that distinguishes between IRQ and MSI\n> \n> Are you suggesting something like:\n> \n> impl ConsumeInterrupt for VirtioPciDevice {\n>         fn trigger() {\n>                 ...\n>         }\n> }\n> But we're not supposed to pass the VirtioPciDevice down to the VirtioDevice, so who would call into this implementation?\n> \n> the PCI bus provides two implementations, one for IRQ and one for MSI\n> \n> PciDevice is a trait. Are you suggesting that PciDevice could also implement ConsumeInterrupt with some default implementation?\n> \n> the VMM uses the closure mechanism you have in intel/cloud-hypervisor#38 <https://github.com/intel/cloud-hypervisor/pull/38> to invoke KVM ioctls or write to eventfds\n> \n> Ok cool!\n> \nSomething looks like below may work. Then the MMIO transport layer will create an instance of DeviceLegacyInterrupt for each VirtioDevice,\nAnd the PCI transport layer will create an instance of DevicePCIInterrupt for each VirtioDevice.\n\n// This trait should be moved into the vm-device crate.\n/// Trait for virtio devices to inject interrupts into the guest.\npub trait DeviceInterrupt {\n    /// Inject the specified interrupt into the guest.\n    fn trigger(&mut self, interrupt_id: u32) -> std::io::Error;\n}\n\nimpl DeviceInterrupt for EventFd {\n    fn trigger(&mut self, interrupt_id: u32) -> std::io::Error {\n        self.write(0)\n    }\n}\n\nimpl DeviceInterrupt For Vec<EventFd> {\n    fn trigger(&mut self, interrupt_id: u32) -> std::io::Error {\n        if interrupt_id as usize >= self.len() {\n            std::io::Error::from_raw_os_error(libc::EINVAL)\n        } else {\n            self[interrupt_id].trigger(0)\n        }\n    }\n}\n\nstruct DeviceLegacyInterrupt {\n    intr_evt: EventFd,\n    intr_status: Arc<AtomicU32>,\n}\n\nimpl DeviceInterrupt for DeviceLegacyInterrupt {\n    fn trigger(&mut self, interrupt_id: u32) -> std::io::Error {\n        self.intr_status.fetch_or(1u32 << interrupt_id, Ordering::SeqCst);\n        self.intr_evt.trigger(0)\n    }\n}\n\nstruct DeviceMSIInterrupt {\n    mode: u32,\n    intr_evt: Vec<EventFd>,\n    intr_status: Arc<AtomicU32>,\n}\n\nimpl DeviceInterrupt for DeviceMSIInterrupt {\n    fn trigger(&mut self, interrupt_id: u32) -> std::io::Error {\n        ....\n    }\n}\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/rust-vmm/vm-virtio/pull/4?email_source=notifications&email_token=AAOXR7GIM6FIPVBQUKOCIG3PY7JJBA5CNFSM4HTT4VFKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXAATGA#issuecomment-499124632>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAOXR7DOXOX6GZKNLHVTLKLPY7JJBANCNFSM4HTT4VFA>.\n> \n\n", "updated_at": "2019-06-05T15:53:08Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499143593", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499143593", "created_at": "2019-06-05T15:53:08Z", "id": 499143593, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTE0MzU5Mw=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "> But we're not supposed to pass the VirtioPciDevice down to the VirtioDevice, so who would\r\n> call into this implementation?\r\n\r\nVirtioDevice could implement the trait, or alternatively it could be passed to activate.\r\n\r\n> > the PCI bus provides two implementations, one for IRQ and one for MSI\r\n>\r\n> PciDevice is a trait. Are you suggesting that PciDevice could also implement ConsumeInterrupt with some default implementation?\r\n\r\nEither that, or it could have metods\r\n\r\n```\r\n    fn intx_handler(&self) -> &LevelTriggeredInterrupt;\r\n    fn msi_handler(&self) -> &EdgeTriggeredInterrupt;\r\n```\r\n\r\n(what I wrote as `ConsumeInterrupt` above, has now become `EdgeTriggeredInterrupt` - sorry about that).", "updated_at": "2019-06-05T16:13:34Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/499151675", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-499151675", "created_at": "2019-06-05T16:13:34Z", "id": 499151675, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5OTE1MTY3NQ=="}, {"user": {"following_url": "https://api.github.com/users/alexandruag/following{/other_user}", "url": "https://api.github.com/users/alexandruag", "site_admin": false, "gists_url": "https://api.github.com/users/alexandruag/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwOTg5Nzg3", "starred_url": "https://api.github.com/users/alexandruag/starred{/owner}{/repo}", "gravatar_id": "", "id": 10989787, "events_url": "https://api.github.com/users/alexandruag/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/10989787?v=4", "login": "alexandruag", "repos_url": "https://api.github.com/users/alexandruag/repos", "subscriptions_url": "https://api.github.com/users/alexandruag/subscriptions", "followers_url": "https://api.github.com/users/alexandruag/followers", "html_url": "https://github.com/alexandruag", "received_events_url": "https://api.github.com/users/alexandruag/received_events", "type": "User", "organizations_url": "https://api.github.com/users/alexandruag/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "Hi everyone, wall of text incoming :( It looks like the functionality that supports Virtio devices in Firecracker and other VMMs can be split into three major components:\r\n\r\n- There's the transport, that handles discovery (when necessary) & configuration in terms of device status, feature negotiation, queue setup, and device-specific configuration space (and also keeps the associated state). \r\n\r\n- Then, we have the queue handler (based on the Virtio queue implementation), which does actions in response to events/notifications associated with queues and/or the device backend. I think this part should be totally agnostic to the mechanism used to deliver notifications; it should just expose functionality such as `handle_this_queue` or `handle_backend`, etc. which is then invoked by the event driver (the following point). The handler must notify the guest on certain occasions, but this can be enabled, for example, via an externally provided closure (I think someone already mentioned this somewhere).\r\n\r\n- Finally, there's an event driver/device state machine of sorts, which handles things like registering io/irq eventfds, other similar things, triggering functionality in response to events, etc. This basically connects the other two components among themselves and to the rest of the VMM.\r\n\r\nWhenever we'd want to use a Virtio device, we pick a transport, a queue handler + backend, and the event driver part to actuate the rest. The event driver is a bit more difficult to precisely define as an interface, because it's naturally related to other rust-vmm high level concepts such as buses and resource allocators, but it looks doable.\r\n\r\nI think there's value in clearly separating the transport and queue handler (for example, right now the `activate` method from the `VirtioDevice` trait assumes `EventFd`s are used no matter what). If we look at an MMIO device, in the separation approach, the event driver passes the appropriate events (MMIO exits) to the transport part, and keeps tabs on its state. When the device is ready to activate, the event driver instantiates the queue handler, and drives it in response to its relevant events (which may arrive via `EventFd`, VM exits, etc). It also propagates any configuration changes, or situations like the elusive device reset. When looking from above, things can get wrapped into different traits and interfaces, but it seems these three are good candidates for the basic building blocks. What do you think?", "updated_at": "2019-06-13T16:39:40Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/501781187", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-501781187", "created_at": "2019-06-13T16:39:40Z", "id": 501781187, "node_id": "MDEyOklzc3VlQ29tbWVudDUwMTc4MTE4Nw=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "On Jun 14, 2019, at 12:39 AM, Alexandru Agache <notifications@github.com <mailto:notifications@github.com>> wrote:\n> \n> Hi everyone, wall of text incoming :( It looks like the functionality that supports Virtio devices in Firecracker and other VMMs can be split into three major components:\n> \nGreat to see discussions about the vm-virtio overall design:)\n> There's the transport, that handles discovery (when necessary) & configuration in terms of device status, feature negotiation, queue setup, and device-specific configuration space (and also keeps the associated state).\n> \nI haven\u2019t get the point why configuration is tied into the transport layer. Device status, feature negotiation, queue setup, and device-specific configuration space should be agonistic to transport layer.\n\n> Then, we have the queue handler (based on the Virtio queue implementation), which does actions in response to events/notifications associated with queues and/or the device backend. I think this part should be totally agnostic to the mechanism used to deliver notifications; it should just expose functionality such as handle_this_queue or handle_backend, etc. which is then invoked by the event driver (the following point). The handler must notify the guest on certain occasions, but this can be enabled, for example, via an externally provided closure (I think someone already mentioned this somewhere).\nWe should support different queue formats here, for the packed vring defined by virtio spec 1.1.\n\n> Finally, there's an event driver/device state machine of sorts, which handles things like registering io/irq eventfds, other similar things, triggering functionality in response to events, etc. This basically connects the other two components among themselves and to the rest of the VMM.\n> \n> Whenever we'd want to use a Virtio device, we pick a transport, a queue handler + backend, and the event driver part to actuate the rest. The event driver is a bit more difficult to precisely define as an interface, because it's naturally related to other rust-vmm high level concepts such as buses and resource allocators, but it looks doable.\n> \n> I think there's value in clearly separating the transport and queue handler (for example, right now the activate method from the VirtioDevice trait assumes EventFds are used no matter what). If we look at an MMIO device, in the separation approach, the event driver passes the appropriate events (MMIO exits) to the transport part, and keeps tabs on its state. When the device is ready to activate, the event driver instantiates the queue handler, and drives it in response to its relevant events (which may arrive via EventFd, VM exits, etc). It also propagates any configuration changes, or situations like the elusive device reset. When looking from above, things can get wrapped into different traits and interfaces, but it seems these three are good candidates for the basic building blocks. What do you think?\n> \n\n\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub <https://github.com/rust-vmm/vm-virtio/pull/4?email_source=notifications&email_token=AAOXR7EE3IC2C6XIKQN6QS3P2JZ43A5CNFSM4HTT4VFKYY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXUJFQY#issuecomment-501781187>, or mute the thread <https://github.com/notifications/unsubscribe-auth/AAOXR7EKQ3QH72FACZ7ONNDP2JZ43ANCNFSM4HTT4VFA>.\n> \n\n", "updated_at": "2019-06-16T08:05:58Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/502430580", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-502430580", "created_at": "2019-06-16T08:05:58Z", "id": 502430580, "node_id": "MDEyOklzc3VlQ29tbWVudDUwMjQzMDU4MA=="}, {"user": {"following_url": "https://api.github.com/users/alexandruag/following{/other_user}", "url": "https://api.github.com/users/alexandruag", "site_admin": false, "gists_url": "https://api.github.com/users/alexandruag/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwOTg5Nzg3", "starred_url": "https://api.github.com/users/alexandruag/starred{/owner}{/repo}", "gravatar_id": "", "id": 10989787, "events_url": "https://api.github.com/users/alexandruag/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/10989787?v=4", "login": "alexandruag", "repos_url": "https://api.github.com/users/alexandruag/repos", "subscriptions_url": "https://api.github.com/users/alexandruag/subscriptions", "followers_url": "https://api.github.com/users/alexandruag/followers", "html_url": "https://github.com/alexandruag", "received_events_url": "https://api.github.com/users/alexandruag/received_events", "type": "User", "organizations_url": "https://api.github.com/users/alexandruag/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/4", "body": "Hi Gerry, my choice of words was poor regarding what I meant by transport, because I was referring to precisely the logic which handles the initial configuration/negotiation/setup of the device. However, I included transport in there because I was under the impression there are at least some slight differences regarding the configuration space itself depending on whether we're dealing with MMIO or PCI devices. You're right we should keep in mind that packed virtqueues are a thing now; this is prob done by having a `Queue` trait implemented by both split and packed queue handling logic. \r\n\r\nSome code would prob be much better at illustrating what I was trying to say, so I'm planning to write a very simple mock design/interface to get feedback from ppl. Btw, is there some overall top-down example/discussion about how the current device/bus/etc proposals interact? Basically, if someone wants to build a vmm with these parts from `rust-vmm`, which are the generic reusable components and what has to be vmm specific? I think this is an important perspective to consider, and I'll try to touch upon it as well.", "updated_at": "2019-06-17T12:13:52Z", "url": "https://api.github.com/repos/rust-vmm/vm-virtio/issues/comments/502657592", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-virtio/pull/4#issuecomment-502657592", "created_at": "2019-06-17T12:13:52Z", "id": 502657592, "node_id": "MDEyOklzc3VlQ29tbWVudDUwMjY1NzU5Mg=="}]