[{"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "Hi all,\r\n\tI have posted the first version of memory-model crate under rust-vmm/memory-model, which breaks the repository inclusion process of the rust-vmm community. So I have created a personal GitHub repository (https://github.com/jiangliu/memory-model) for v2 and the rust-vmm/memory-model repository will be deleted soon. Sorry for the inconvenience!\r\n\tThe main change from v1 to v2 is the introduction of the AddressSpace abstraction, which is used to present the physical address space of a virtual machine. An AddressSpace object contains guest memory(RAM) regions and MMIO regions for devices. There are two possible ways to make use of the memory-model crate:\r\n\t1) Use the GuestMemory to represent a virtual machine address space, as it\u2019s used currently by the firecracker and crosvm project.\r\n\t2) Use the AddressSpace to represent a virtual machine address space, and build GuestMemory objects from the AddressSpace object on demand. So different permission and protection mechanisms may be applied to different regions in guest address space. For example we may protect guest kernel code region with advanced EPT permission flags. It may help to mitigate the security concerns mentioned on the last meeting.\r\n\r\n\tOn the other hand, the memory-model crate needs to satisfy requirements from both crosvm and firecracker, and currently the most sensitive conflict is that crosvm uses u64 for memory related fields but firecracker uses usize instead. As the valid usage case Zack has mentioned:\r\n\t\"On 64-bit arm devices, we usually run a 32-bit userspace with a 64-bit kernel. In this case, the machine word size (usize) that crosvm is compiled with (32-bit) isn't the same as the one the guest kernel, host kernel, hardware is using (64-bit). We used u64 to ensure that the size was always at least as big as needed.\u201c\r\n\t\r\nSo we can\u2019t simply replace u64 with usize. With the introduction of the AddressSpace abstraction, the proposal to solve this conflict is:\r\n\t1) Use u64 for all fields related to virtual machine physical address space. Most fields of the AddressSpace and GuestAddress structure falls into this category.\r\n\t2) Use usize for all fields representing address/size in current process(VMM). Most fields of the MemoryMapping and GuestMemory structure falls into this category.\r\n\tIf the proposal is the right way to go, I will posted a v3 with the proposed solution.\r\n\t\r\nThanks,\r\nGerry", "updated_at": "2019-02-11T13:02:54Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/462319465", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-462319465", "created_at": "2019-02-11T13:02:05Z", "id": 462319465, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjMxOTQ2NQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "This review is based on commit [ab37cf3324310b074869680b3a471ca436f51a68 at jiangliu/memory-model](https://github.com/jiangliu/memory-model/tree/ab37cf3324310b074869680b3a471ca436f51a68).\r\n\r\nA memory model crate is certainly a very good starting point for rust-vmm, but it shouldn't include the implementation of the backend. Instead, for rust-vmm we should focus on defining common traits that can be used by any VMM.\r\n\r\nIn this light, GuestMemory is composed of two parts that are completely independent. The first is a way to convert a GuestAddress to a MemoryMapping and an offset, which can be a very simple MemoryMap trait:\r\n\r\n     pub trait MemoryMap {\r\n        type Region: Bytes<usize> /* see below */ ;\r\n        fn do_in_region<F, T>(&self, guest_addr: GuestAddress,\r\n                              size: usize, cb: F) -> Result<T>\r\n        where\r\n          F: FnOnce(&Self::Region, usize) -> Result<T>;\r\n    \r\n        fn do_in_region_partial<F>(&self, guest_addr: GuestAddress,\r\n                                       cb: F) -> Result<usize>\r\n        where\r\n          F: FnOnce(&Self::Region, usize) -> Result<usize>;\r\n    }\r\n\r\nThis can be implemented with linear lookup as is currently the case in firecracker, or it could use a binary search or a radix tree.  rust-vmm shouldn't care. It should only define the trait so that (for example) virtio crates can receive a MemoryMap and access it.\r\n\r\nThe second part is the convenience API to access memory as slices/streams/objects. This part of the API is actually shared by MemoryMapping and GuestMemory:\r\n\r\n    // From MemoryMapping\r\n    pub fn read_to_memory<F>(&self, mem_offset: usize, src: &mut F,\r\n                              count: usize) -> Result<()>\r\n        where F: Read;\r\n\r\n     // From GuestMemory\r\n     pub fn read_to_memory<F>(&self, guest_addr: GuestAddress,\r\n                              src: &mut F, count: usize) -> Result<()>\r\n       where F: Read;\r\n\r\n... though sometimes the methods have different names:\r\n\r\n    // From MemoryMapping\r\n    pub fn write_slice(&self, buf: &[u8], offset: usize) -> Result<usize>;\r\n    pub fn read_obj<T: DataInit>(&self, offset: usize) -> Result<T>;\r\n\r\n    // From GuestMemory\r\n     pub fn write_slice_at_addr(&self, buf: &[u8], guest_addr: GuestAddress)\r\n        -> Result<usize>;\r\n    pub fn read_obj_from_addr<T: DataInit>(&self, guest_addr: GuestAddress)\r\n        -> Result<T>;\r\n\r\nThis API should be a trait that is implemented by both `MemoryMapping` and `GuestMemory`. For example if we call it `Bytes<O>`,` MemoryMapping` would implement `Bytes<usize>` and `GuestMemory` would implement `Bytes<GuestAddress>`. \r\n\r\n    // O for offset\r\n    pub trait Bytes<O> {\r\n        type Error;\r\n    \r\n        // Perhaps rename it to \"read_from\"?\r\n        fn read_to_memory<F>(&self, offset: O, src: &mut F,\r\n                          count: usize) -> Result<(), Self::Error>\r\n          where F: Read;\r\n        // Perhaps rename it to just \"read\"?\r\n        fn read_obj<T: DataInit>(&self, offset: O) -> Result<T, Self::Error>;\r\n        ...\r\n        fn read_slice(&self, buf: &[u8], mem_offset: O) ->\r\n          Result<usize, Self::Error>;\r\n        ...\r\n    }\r\n\r\n(Alternatively, the offset type could be an associated type. Opinions are welcome from people more familiar with Rust API design, but I think it's better to have it as an argument so that `MemoryMap` can declare `type Region: Bytes<usize>`).\r\n\r\nThe `memory-model` crate should definitely provide an implementation of `Bytes<GuestAddress>` for `MemoryMap`, based on the current implementation of `GuestMemory`. However, the rest of `GuestMemory` and `MemoryMapping` could be provided in a separate repository (`rust-vmm-examples`?) as a reference implementation. There's always time to \"graduate\" things from rust-vmm-examples to rust-vmm.\r\n\r\n`AddressSpace` is too specialized. I would leave it out completely from the time being; again there's always time to add stuff, removing is harder.\r\n\r\nOn the other hand, I am very positive that `endian.rs` should be part of this crate from the very beginning, so that you can write\r\n\r\n    let x: LE<u32> = mem.read_obj(ofs);\r\n\r\nNo objections from me of course on other parts of the crate, for example `VolatileMemory` or `DataInit`.", "updated_at": "2019-02-11T21:57:32Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/462322281", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-462322281", "created_at": "2019-02-11T13:12:29Z", "id": 462322281, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjMyMjI4MQ=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "@bonzini \r\nSo the key idea is to build a layer architecture as [vm_mem_accessor] -> [vm_mem_access_mechanism] -> [vm_mem_content_backend]. The vm_mem_accessor layer defines interfaces to access vm memory, and all clients such as VMMs, virtio drivers and vhost-user drivers only have dependency on this layer. The vm_mem_access_mechanism layer implements the mechanism to access vm memory by means of mmap, file rw, ioctl or even RPC. And the vm_mem_content_backend may be anonymous memory, memfd, file or even some virtual content.\r\nFor the memory-model crate, it should only cover the vm_mem_accessor layer, and the two lower layers should be covered by other crates and may have different implementation for qemu and firecracker.\r\nBy this way, it may need more changes to the crosvm and firecracker project. So need feedbacks from them:)", "updated_at": "2019-02-11T14:32:24Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/462347936", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-462347936", "created_at": "2019-02-11T14:32:24Z", "id": 462347936, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjM0NzkzNg=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "> [vm_mem_accessor] -> [vm_mem_access_mechanism] -> [vm_mem_content_backend].\r\n\r\nRight, which in my description are `Bytes<GuestAddress>`, `MemoryMap` and `Bytes<usize>`.  All three are traits so you're free to plug in whatever implementation you want.\r\n\r\n> For the memory-model crate, it should only cover the vm_mem_accessor layer, and the two lower layers \r\n> should be covered by other crates and may have different implementation for qemu and firecracker.\r\n\r\nYes. More precisely memory-model should provide the traits for all three layers. It turns out that:\r\n\r\n* two layers are just specializations of the same \"byte-level access\" trait\r\n\r\n* what you called vm_mem_accessor (`Bytes<GuestAddress>`) admits a useful implementation for any vm_mem_access_mechanism (i.e. an implementation in terms of `MemoryMap`). Therefore, `impl<T> Bytes<GuestAddress> for T where T: MemoryMap` can be in memory-model too.\r\n\r\nAs you say it's not just QEMU and Firecracker, vhost-user crates should also be able to use `MemoryMap` and `Bytes<>`, so that they can share the virtqueue implementation with Firecracker. Starting with traits makes it harder to over-specify things.\r\n\r\n> By this way, it may need more changes to the crosvm and firecracker project. So need feedbacks from \r\n> them:)\r\n\r\nSure. Hopefully the changes to crosvm and firecracker amount to little more than search-and-replace.", "updated_at": "2019-02-11T17:45:45Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/462406667", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-462406667", "created_at": "2019-02-11T17:00:50Z", "id": 462406667, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjQwNjY2Nw=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "@alexandruag @dhrgit can you also take a look at this?", "updated_at": "2019-02-11T17:44:32Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/462423375", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-462423375", "created_at": "2019-02-11T17:44:32Z", "id": 462423375, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2MjQyMzM3NQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "One issue regarding testing: even if we can have a reference implementation in a different \u201cexample\u201d crate, or we need an implementation of the traits to test the whole thing.\r\n\r\nWhat does everyone think of implementing `Bytes<usize>` for `&mut [u8]` inside this crate? This would replace `MemoryMapping` in the tests.", "updated_at": "2019-02-19T18:13:27Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/465247131", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-465247131", "created_at": "2019-02-19T18:13:17Z", "id": 465247131, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTI0NzEzMQ=="}, {"user": {"following_url": "https://api.github.com/users/alexandruag/following{/other_user}", "url": "https://api.github.com/users/alexandruag", "site_admin": false, "gists_url": "https://api.github.com/users/alexandruag/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwOTg5Nzg3", "starred_url": "https://api.github.com/users/alexandruag/starred{/owner}{/repo}", "gravatar_id": "", "id": 10989787, "events_url": "https://api.github.com/users/alexandruag/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/10989787?v=4", "login": "alexandruag", "repos_url": "https://api.github.com/users/alexandruag/repos", "subscriptions_url": "https://api.github.com/users/alexandruag/subscriptions", "followers_url": "https://api.github.com/users/alexandruag/followers", "html_url": "https://github.com/alexandruag", "received_events_url": "https://api.github.com/users/alexandruag/received_events", "type": "User", "organizations_url": "https://api.github.com/users/alexandruag/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "Hi everyone,\r\n\r\nApologies for joining the discussion so late. I really like @bonzini's point of view; it makes sense to have `memory_model` expose an interface, and then also have some sort of default/reference implementation in another crate. Here are just a few remarks/questions I kinda have on this topic.\r\n\r\nThe implementation of `GuestMemory` in CrosmVM (and by extension Firecracker) exhibits interior mutability, so mutable operations (like writes) are done using a regular `&GuestMemory` borrow. This is very helpful when multiple references to the same guest memory are lying around (especially for different threads), otherwise we'd have to use `RefCell`s or `Mutex`es and the like. I was just wondering if we miss something with this abstraction. Can anyone imagine a (useful) scenario where having a meaningful distinction between a `&GuestMemory` and a `&mut GuestMemory` makes sense?\r\n\r\nIf `Region` is a part of the interface exposed by `MemoryMap`, maybe we should have an actual trait like:\r\n\r\n```rust\r\npub trait GuestMemoryRegion<T>: Bytes<T> {\r\n    fn host_address(&self) -> usize;\r\n    fn guest_address(&self) -> usize;\r\n    fn size(&self) -> usize;\r\n}  \r\n```\r\n\r\nI used `usize` as the return type for the  methods above, but it might as well be anything else. If components such as KVM high-level wrappers also end up interacting with things that implement `GuestMemory`, as opposed to a particular implementation, we need more info about the regions for setting up memory slots, etc. I imagine there are other use cases where this is nice to know, at least for info/debugging purposes.\r\n\r\nSpeaking of regions, what do you think about having some sort of slice (or view if you will) analogue for `GuestMemory`. For example, let's say I'm writing some device model code and I'm afraid a malicious driver will try to make me access certain memory areas by providing invalid descriptor indices. I can add bound checks and all that, but it seems nicer if I could operate on a 'slice' of the GuestMemory, restricted to precisely the memory area(s) used to interact with the suspicious device. I don't know if this makes that much sense, just throwing the idea out there :D\r\n\r\nThe `u64` vs `usize` debate raised a very interesting point. In the end, is it ok to have a predefined  underlying datatype (`u64` in this case) for the `GuestAddress` offset? Would it make sense for `GuestMemory` to become generic in that regard? It looks tricky to define an abstraction that's not awkward to use, but it should be doable if there are good reasons to think about it :D\r\n\r\nAt this point I guess the next step is having some sort of initial version/proposal for the complete interface. Thanks for taking the time to read all of this!\r\n", "updated_at": "2019-02-20T12:28:03Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/465553974", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-465553974", "created_at": "2019-02-20T12:28:03Z", "id": 465553974, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTU1Mzk3NA=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": ">Speaking of regions, what do you think about having some sort of slice (or view if you will) analogue for >`GuestMemory`. For example, let's say I'm writing some device model code and I'm afraid a malicious driver >will try to make me access certain memory areas by providing invalid descriptor indices. I can add bound >checks and all that, but it seems nicer if I could operate on a 'slice' of the GuestMemory, restricted to >precisely the memory area(s) used to interact with the suspicious device. I don't know if this makes that >much sense, just throwing the idea out there :D\r\n\r\nHow about rethink about the AddressSpace abstraction?\r\nI tried to solve above issue by introducing the AddressSpace abstraction, which contains group of guest memory regions with different types/properties. Then GuestMemory is used to map partial or full of the regions  in AddressSpace into current process. By this way, we may build a GuestMemory object for device, another GuestMemory object for the boot loader.", "updated_at": "2019-02-20T18:41:43Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/465639916", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-465639916", "created_at": "2019-02-20T16:01:32Z", "id": 465639916, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTYzOTkxNg=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "> The implementation of `GuestMemory` in CrosmVM (and by extension Firecracker) exhibits interior mutability, so mutable operations (like writes) are done using a regular `&GuestMemory` borrow. This is very helpful when multiple references to the same guest memory are lying around (especially for different threads), otherwise we'd have to use `RefCell`s or `Mutex`es and the like. I was just wondering if we miss something with this abstraction. Can anyone imagine a (useful) scenario where having a meaningful distinction between a `&GuestMemory` and a `&mut GuestMemory` makes sense?\r\n\r\nI suppose it is sound because all reads/writes are for types that are `DataInit`? If so I guess it's okay, even if you lose a little bit in safety. Most guest memory accesses are atomic-like anyway. A `Mutex` would make no sense when the guest can anyway perform accesses without taking it.\r\n\r\nRegarding GuestMemoryRegion, instead I think that `Region` could become a generic argument `MemoryMap<R>` instead of an associated type. Then KVM bindings could use be written to expect a `MemoryMap<MemoryMapping>` and use that to access the host address in the callers of `do_in_region` and the like.", "updated_at": "2019-02-20T18:21:27Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/465696077", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-465696077", "created_at": "2019-02-20T18:21:27Z", "id": 465696077, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NTY5NjA3Nw=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "Hi all,\r\n   I have posted the design doc at https://github.com/rust-vmm/community/issues/22 and you may access the latest code at my personal github repository: https://github.com/jiangliu/memory-model/tree/v2\r\nthanks,\r\nGerry", "updated_at": "2019-02-25T10:49:54Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/466965789", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-466965789", "created_at": "2019-02-25T10:49:54Z", "id": 466965789, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2Njk2NTc4OQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/16", "body": "Thanks! Let's move the discussion there. @andreeaflorescu can you close this one?", "updated_at": "2019-02-25T18:22:34Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/467121347", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/16#issuecomment-467121347", "created_at": "2019-02-25T18:22:34Z", "id": 467121347, "node_id": "MDEyOklzc3VlQ29tbWVudDQ2NzEyMTM0Nw=="}]