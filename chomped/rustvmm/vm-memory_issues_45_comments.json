[{"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "It's marked unsafe because of \"possible aliasing\", so it's a special purposed slice and the caller needs to take care of possible aliasing.", "updated_at": "2019-10-22T03:49:02Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/544794751", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-544794751", "created_at": "2019-10-22T03:49:02Z", "id": 544794751, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NDc5NDc1MQ=="}, {"user": {"following_url": "https://api.github.com/users/zachreizner/following{/other_user}", "url": "https://api.github.com/users/zachreizner", "site_admin": false, "gists_url": "https://api.github.com/users/zachreizner/gists{/gist_id}", "node_id": "MDQ6VXNlcjI5MjcxMQ==", "starred_url": "https://api.github.com/users/zachreizner/starred{/owner}{/repo}", "gravatar_id": "", "id": 292711, "events_url": "https://api.github.com/users/zachreizner/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/292711?v=4", "login": "zachreizner", "repos_url": "https://api.github.com/users/zachreizner/repos", "subscriptions_url": "https://api.github.com/users/zachreizner/subscriptions", "followers_url": "https://api.github.com/users/zachreizner/followers", "html_url": "https://github.com/zachreizner", "received_events_url": "https://api.github.com/users/zachreizner/received_events", "type": "User", "organizations_url": "https://api.github.com/users/zachreizner/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "There are two reasons why the functions can not ensure safely, even though it is marked unsafe. The first is that the `read_from` function will pass the slice returned from `as_mut_slice` to a generic `io::Write` implementation which may not respect the unsafe nature of the slice it was given. The second is that creating primitive slices from memory that does not obey the Rust rules:\r\n\r\n- A mutable reference cannot be aliased\r\n- Safe Rust can not cause a data race\r\n\r\nis inherently undefined behavior because their is no defined proper usage. Similar to how `mem::uninitialized` was too undefined to use properly, instantiating slices that don't adhere to Rust's safety rules is \"instantaneously\" UB.", "updated_at": "2019-10-22T08:59:55Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/544867739", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-544867739", "created_at": "2019-10-22T08:57:30Z", "id": 544867739, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NDg2NzczOQ=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "It's definitely true that current design/implementation may cause UB, so it's treat off between complex, performance and call responsibilities. Current implementation prefers performance/simplicity by shifting the responsibilities to callers to:\r\n1) ensure no current accesses to the returned slices from the VMM side.\r\n2) ensure no current accesses to the returned slices from the VMM and guest side.\r\n\r\nIt does break the rust memory safety rules, improvements are welcomed:)", "updated_at": "2019-10-22T09:53:11Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/544887153", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-544887153", "created_at": "2019-10-22T09:53:11Z", "id": 544887153, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NDg4NzE1Mw=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "How is `as_mut_slice` returning a possibly-aliased reference different from writing `&mut *a` where `a` is a mutable pointer? (serious question, not rhetorical).", "updated_at": "2019-10-22T09:56:14Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/544888194", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-544888194", "created_at": "2019-10-22T09:56:14Z", "id": 544888194, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NDg4ODE5NA=="}, {"user": {"following_url": "https://api.github.com/users/zachreizner/following{/other_user}", "url": "https://api.github.com/users/zachreizner", "site_admin": false, "gists_url": "https://api.github.com/users/zachreizner/gists{/gist_id}", "node_id": "MDQ6VXNlcjI5MjcxMQ==", "starred_url": "https://api.github.com/users/zachreizner/starred{/owner}{/repo}", "gravatar_id": "", "id": 292711, "events_url": "https://api.github.com/users/zachreizner/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/292711?v=4", "login": "zachreizner", "repos_url": "https://api.github.com/users/zachreizner/repos", "subscriptions_url": "https://api.github.com/users/zachreizner/subscriptions", "followers_url": "https://api.github.com/users/zachreizner/followers", "html_url": "https://github.com/zachreizner", "received_events_url": "https://api.github.com/users/zachreizner/received_events", "type": "User", "organizations_url": "https://api.github.com/users/zachreizner/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "Answering @bonzini's question: with respect to Rust safety around aliasing is concerned, there is no difference. If `a` is a pointer to guest memory, it violate Rust safety (and is therefore UB), to have the expression `&mut *a`.", "updated_at": "2019-10-22T10:33:16Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/544900153", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-544900153", "created_at": "2019-10-22T10:33:16Z", "id": 544900153, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NDkwMDE1Mw=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "Then it is up to the user to use `as_mut_slice` safely, as with all unsafe functions. It is for example safe to use it before the guest has started. Also, the whole idea behind VolatileMemory is that, for ByteValued types, accesses to `*mut u8` are \"not entirely\" undefined behavior:\r\n\r\n> `VolatileRef` and `VolatileSlice`, along with types that [...] implement\r\n> `VolatileMemory`, allow us to sidestep that rule by wrapping pointers that absolutely have to be\r\n> accessed volatile.\r\n\r\nThe head comment of src/volatile_memory.rs goes on to say \"For the purposes of maintaining safety [...] No references or slices to volatile memory [...] Access should always been done with a volatile read or write\" but these rules do not apply to `unsafe` code.", "updated_at": "2019-10-23T08:31:28Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/545332274", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-545332274", "created_at": "2019-10-23T08:31:28Z", "id": 545332274, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NTMzMjI3NA=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "With respect to \"not entirely\" undefined behavior, see also this FIXME comment:\r\n\r\n            // Safe because the pointers are range-checked when the slices\r\n            // are created, and they never escape the VolatileSlices.\r\n            // FIXME: ... however, is it really okay to mix non-volatile\r\n            // operations such as copy with read_volatile and write_volatile?\r\n            copy(self.addr, slice.addr, min(self.size, slice.size));\r\n", "updated_at": "2019-10-23T08:32:20Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/545332630", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-545332630", "created_at": "2019-10-23T08:32:20Z", "id": 545332630, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NTMzMjYzMA=="}, {"user": {"following_url": "https://api.github.com/users/zachreizner/following{/other_user}", "url": "https://api.github.com/users/zachreizner", "site_admin": false, "gists_url": "https://api.github.com/users/zachreizner/gists{/gist_id}", "node_id": "MDQ6VXNlcjI5MjcxMQ==", "starred_url": "https://api.github.com/users/zachreizner/starred{/owner}{/repo}", "gravatar_id": "", "id": 292711, "events_url": "https://api.github.com/users/zachreizner/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/292711?v=4", "login": "zachreizner", "repos_url": "https://api.github.com/users/zachreizner/repos", "subscriptions_url": "https://api.github.com/users/zachreizner/subscriptions", "followers_url": "https://api.github.com/users/zachreizner/followers", "html_url": "https://github.com/zachreizner", "received_events_url": "https://api.github.com/users/zachreizner/received_events", "type": "User", "organizations_url": "https://api.github.com/users/zachreizner/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "There is unsafety possible in the use of `GuestMemory::read_from`, which itself is *not* marked unsafe. Consider this pseudo-code:\r\n\r\n```\r\nlet addr = ....;\r\nlet mem = GuestMemoryMmap::new(....);\r\nlet mem_cloned = mem.clone();\r\nspawn(|| mem_cloned.read_from(addr, &mut SafeReader, 100);\r\nmem.read_from(addr, &mut SafeReader, 100);\r\n\r\nstruct SafeReader;\r\nimpl Read for SafeReader {\r\n    fn read(&mut self, buf: &mut [u8]) -> Result<usize> {\r\n        let x = buf[0];\r\n        buf[0] = x;\r\n        assert_eq!(x, buf[0]);\r\n        Ok(1)\r\n    }\r\n}\r\n```\r\nBecause `read_from` is called twice over the same section of shared memory in a concurrent fashion, the result of the assertion in the `SafeReader` implementation is undefined because of the race condition. I hope we can agree that [two concurrent threads with a mutable reference to the same data is never acceptable in Rust](https://doc.rust-lang.org/nomicon/references.html).\r\n\r\nI also want to stress the point that `unsafe` does *not* mean we are allowed to create aliased mutable references, even though `unsafe` _allows_ such an event to occur. Violating certain invariants in Rust invokes undefined behavior, which [we don't want to do](https://doc.rust-lang.org/nomicon/what-unsafe-does.html). Merely creating aliased mutable references violates the pointer aliasing rule, which means there is no way to call `as_mut_slice` without invoking undefined behavior. It doesn't even matter how we use it after, the damage would have been done.", "updated_at": "2019-10-23T14:49:00Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/545480835", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-545480835", "created_at": "2019-10-23T14:49:00Z", "id": 545480835, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NTQ4MDgzNQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "> I hope we can agree that two concurrent threads with a mutable reference to the same data is never acceptable in Rust.\r\n\r\nYou do have two concurrent threads with a mutable reference, if one thread accesses it through VolatileMemory and the other does it in KVM_RUN. So my understanding is that VolatileMemory knowingly bends that rule more than a little bit.\r\n\r\n> I also want to stress the point that unsafe does not mean we are allowed to create aliased mutable references, even though unsafe allows such an event to occur\r\n\r\nI agree, but isn't this case more or less the same as the `copy` case in `copy_to_volatile_slice`? `copy_to_volatile_slice`:\r\n\r\n* is not marked unsafe\r\n\r\n* takes a non-mutable `VolatileSlice` as the destination, and creating a `VolatileSlice` can create multiple aliasing `*mut u8`\r\n\r\n* dereferences a `*mut u8` in such a way that you would have two concurrent pointer copies.", "updated_at": "2019-10-24T13:33:45Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/545920161", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-545920161", "created_at": "2019-10-24T13:33:45Z", "id": 545920161, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NTkyMDE2MQ=="}, {"user": {"following_url": "https://api.github.com/users/alexandruag/following{/other_user}", "url": "https://api.github.com/users/alexandruag", "site_admin": false, "gists_url": "https://api.github.com/users/alexandruag/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwOTg5Nzg3", "starred_url": "https://api.github.com/users/alexandruag/starred{/owner}{/repo}", "gravatar_id": "", "id": 10989787, "events_url": "https://api.github.com/users/alexandruag/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/10989787?v=4", "login": "alexandruag", "repos_url": "https://api.github.com/users/alexandruag/repos", "subscriptions_url": "https://api.github.com/users/alexandruag/subscriptions", "followers_url": "https://api.github.com/users/alexandruag/followers", "html_url": "https://github.com/alexandruag", "received_events_url": "https://api.github.com/users/alexandruag/received_events", "type": "User", "organizations_url": "https://api.github.com/users/alexandruag/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "Hi everyone! A couple of questions come to mind looking at this discussion. First of all, there are [some](https://doc.rust-lang.org/reference/behavior-considered-undefined.html) (apparently older) Rust docs that mention aliasing rules should hold for raw pointers as well, whereas [others](https://doc.rust-lang.org/book/raw-pointers.html) state (FWIW) that raw pointers are allowed to ignore many of the rules references have to follow. Is there a way to conclude whether raw pointers and refs/slices are subject to the same aliasing rules or not?\r\n\r\nSecond, can we determine if aliasing for raw data bytes in particular actually poses any risk?  I imagine the compiler/optimizer/etc is free to do a lot of things with a `&mut` when it gets one, but is there any danger when it's \"just\" a `&mut [u8]` for example? I imagine this is implementation specific, but maybe there's a way to know for sure. I've been digging for a little while, but no success so far :(\r\n", "updated_at": "2019-10-27T12:28:55Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/546689883", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-546689883", "created_at": "2019-10-27T12:28:55Z", "id": 546689883, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NjY4OTg4Mw=="}, {"user": {"following_url": "https://api.github.com/users/zachreizner/following{/other_user}", "url": "https://api.github.com/users/zachreizner", "site_admin": false, "gists_url": "https://api.github.com/users/zachreizner/gists{/gist_id}", "node_id": "MDQ6VXNlcjI5MjcxMQ==", "starred_url": "https://api.github.com/users/zachreizner/starred{/owner}{/repo}", "gravatar_id": "", "id": 292711, "events_url": "https://api.github.com/users/zachreizner/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/292711?v=4", "login": "zachreizner", "repos_url": "https://api.github.com/users/zachreizner/repos", "subscriptions_url": "https://api.github.com/users/zachreizner/subscriptions", "followers_url": "https://api.github.com/users/zachreizner/followers", "html_url": "https://github.com/zachreizner", "received_events_url": "https://api.github.com/users/zachreizner/received_events", "type": "User", "organizations_url": "https://api.github.com/users/zachreizner/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "> I agree, but isn't this case more or less the same as the `copy` case in `copy_to_volatile_slice`? `copy_to_volatile_slice`:\r\n> \r\n> * is not marked unsafe\r\n> * takes a non-mutable `VolatileSlice` as the destination, and creating a `VolatileSlice` can create multiple aliasing `*mut u8`\r\n> * dereferences a `*mut u8` in such a way that you would have two concurrent pointer copies.\r\n\r\nThe issue is with aliased mutable primitive references (i.e. `&mut T`), which allows UB in safe code. `VolatileSlice` should not be bending rules about primitive references because it doesn't use any, using `*mut u8` instead. AFAICT, raw pointers in Rust do not have rules around aliasing and the Rust language does not have any implicit rules w.r.t. `VolatileSlice` that could lead to UB.", "updated_at": "2019-10-28T23:24:49Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/547188867", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-547188867", "created_at": "2019-10-28T23:24:49Z", "id": 547188867, "node_id": "MDEyOklzc3VlQ29tbWVudDU0NzE4ODg2Nw=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/45", "body": "Concurrency is the issue. [Data races have undefined behavior](https://doc.rust-lang.org/nomicon/races.html) so two concurrent `std::ptr::copy` operations to the same destination are UB.\r\n\r\nThat said, while I believe that `as_slice` can live (as an unsafe method at least), the volatile memory part is definitely incomplete in rust-vmm. At the very least we need the volatile read/write traits from crosvm.", "updated_at": "2019-11-01T10:45:46Z", "url": "https://api.github.com/repos/rust-vmm/vm-memory/issues/comments/548745429", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/vm-memory/issues/45#issuecomment-548745429", "created_at": "2019-11-01T10:45:46Z", "id": 548745429, "node_id": "MDEyOklzc3VlQ29tbWVudDU0ODc0NTQyOQ=="}]