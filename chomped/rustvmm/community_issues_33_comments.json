[{"user": {"following_url": "https://api.github.com/users/liujing2/following{/other_user}", "url": "https://api.github.com/users/liujing2", "site_admin": false, "gists_url": "https://api.github.com/users/liujing2/gists{/gist_id}", "node_id": "MDQ6VXNlcjM5Njg0NjQ5", "starred_url": "https://api.github.com/users/liujing2/starred{/owner}{/repo}", "gravatar_id": "", "id": 39684649, "events_url": "https://api.github.com/users/liujing2/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/39684649?v=4", "login": "liujing2", "repos_url": "https://api.github.com/users/liujing2/repos", "subscriptions_url": "https://api.github.com/users/liujing2/subscriptions", "followers_url": "https://api.github.com/users/liujing2/followers", "html_url": "https://github.com/liujing2", "received_events_url": "https://api.github.com/users/liujing2/received_events", "type": "User", "organizations_url": "https://api.github.com/users/liujing2/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@chao-p  Yep, I also did some investigation on the devices crate. Bus, pure pci, virtio-common for both pci and mmio are the first step I think, and next, we add legacy, virtio-block, virtio-net, etc. as the real devices into the crate for the second step.", "updated_at": "2019-03-12T06:32:32Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/471874576", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-471874576", "created_at": "2019-03-12T06:32:32Z", "id": 471874576, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MTg3NDU3Ng=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": " To be a little more concrete I think this should provide:\r\n\r\n### Device trait\r\n\r\nTo start simple, I think our device trait could look like:\r\n\r\n```Rust\r\npub trait Device: Send {\r\n    /// Reads at `offset` from this device\r\n    fn read(&mut self, offset: u64, data: &mut [u8]) {}\r\n \r\n    /// Writes at `offset` into this device\r\n    fn write(&mut self, offset: u64, data: &[u8]) {}\r\n}\r\n```\r\nThen we can expand it to support the Firecracker and crosvm uses cases through further PRs.\r\n\r\n#### Device traits implementations for \"legacy\"/ioport based devices\r\n\r\nInitially we could have reference implementations of the `Device` trait for the Serial, keyboard and CMOS\r\ndevices.\r\n\r\n#### virtio transport implementations(?)\r\nBoth the MMIO and PCI virtio transport support would become a `Device` trait implementations.\r\nArguably, those implementation could live in either the `vm-devices` or the `virtio-devices` crate. Maybe it would make more sense to have the `virtio-devices` crate depend on `vm-devices` and not the other way around, and keep all virtio related implementations there.\r\n\r\n### A Bus trait\r\n\r\nThe current `firecracker` and `crosvm`  `Bus` implementation uses a binary tree to represent a devices bus, but we may want to allow for more flexibility by providing a trait and then having a binary tree implementation of this trait.\r\n\r\n```Rust\r\npub trait Bus: Send {\r\n    // Returns a device living at addr\r\n    pub fn get_device(&self, addr: u64) -> Option<(u64, &Mutex<Device>)> ;\r\n\r\n    /// Puts the given device at the given address space.\r\n    pub fn insert(&mut self, device: Arc<Mutex<Device>>, base: u64, len: u64) -> Result<()>;\r\n\r\n    /// Reads data from the device that owns the range containing `addr` and puts it into `data`.\r\n    ///\r\n    /// Returns true on success, otherwise `data` is untouched.\r\n    pub fn read(&self, addr: u64, data: &mut [u8]) -> bool;\r\n\r\n    /// Writes `data` to the device that owns the range containing `addr`.\r\n    ///\r\n    /// Returns true on success, otherwise `data` is untouched.\r\n    pub fn write(&self, addr: u64, data: &[u8]) -> bool\r\n}\r\n``` \r\n\r\nSome comments:\r\n\r\n* Would a Bus trait be too much of an abstraction?\r\n* Should we provide a defaut implementation for the read and write methods? Most of the time it will be about finding the device with `get_device` and then reading or writing from and to it respectively.\r\n\r\n#### A bus trait implementation\r\nUsing a binary tree.\r\n\r\n### Device manager\r\n\r\nFor:\r\n\r\n* Managing the device ranges and address spaces. Have it manage MMIO and IO ports conflicts and reserve the right ranges on behalf of the caller if needed.\r\n* Manage and order buses. Without a device manager, we won't be able to see the full machine devices topology", "updated_at": "2019-03-13T19:11:51Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/472565149", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-472565149", "created_at": "2019-03-13T19:11:51Z", "id": 472565149, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3MjU2NTE0OQ=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "Basing on above suggestion from Samuel, we did some experiment and after that we have a updated and slightly different design.\r\n\r\nThe major motivation for this moving comes from some situations we observed for a device:\r\n\r\n- A single device can have multiple PIO/MMIO ranges, e.g. PCI can have multiple BARs\r\n- A single device can have both PIO and MMIO range, again, PCI device is an example\r\n- Not all registers in a device's MMIO space require a trap from guest, e.g. virtio devices have a large MMIO space however we may only need to trap for the 'notification' register.\r\n\r\n### Overview\r\nThere are two design proposals. The major difference is Design 2 removes Bus trait comparing to Design 1. The key idea behind this is making DeviceManager a central place for resource(PIO/MMIO/interrupt)  management and providing 'service' API for devices to allocate/register these resources during a new 'init' stage. A device can allocate multiple of these resources and can register dedicated read/write ops for certain MMIO/PIO range.\r\n\r\n#### Design 1\r\n![device-design](https://user-images.githubusercontent.com/11373652/54752195-33977200-4c18-11e9-8f8b-bf2512286ef5.jpg)\r\n#### Design 2\r\n![device-design-nobus](https://user-images.githubusercontent.com/11373652/54757053-69425800-4c24-11e9-9809-3838f59265c3.jpg)\r\n\r\n### Device\r\n```rust\r\npub trait Device {\r\n    /// Get the device name\r\n    fn get_name(&self) -> String;\r\n    /// Device initialization\r\n    fn init(&self, dev_mgr: DeviceManager);\r\n    /// Device shutdown\r\n    fn exit(&self);\r\n}\r\n```\r\n### Bus\r\nBus is a logic collection of devices and can form the topology of the device tree in a system. There can be very minimal abstract (Design 1) or no abstract at all (Design 2). If implemented it will looks like:\r\n```rust\r\npub trait Bus: Device + Iterator {\r\n}\r\n```\r\nWe treat Bus as Device, so it will also have its 'init' function and can register read/write ops for PIO/MMIO range it cares. This is useful for PCIBus for example, it can intercept 0xcfc/0xcf8 in its 'init' function and dispatch it to config_read/config_write of PCI device attached to it.\r\n\r\nPlease note read/write ops that individual device registered in its 'init' function will not be dispatched through the bus it attached and will be dispatched from DeviceManager directly.\r\n\r\n### Device Manger\r\nDeviceManager provides resource management as well as managing the root buses or devices. It will also intercept with external crates, e.g. memory model/hypervisor components.\r\n\r\n### Device Creation/Initialization Sample Code (with Design 1)\r\n```rust\r\nlet dev_mgr = DeviceManager::new();\r\nlet pci_bus = PCIBus::new();\r\ndev_mgr.insert_bus(pci_bus);\r\nlet pci_dev = DummyDevice::new();\r\npci_bus.insert(pci_dev);\r\n   ...\r\ndev_mgr.init();\r\n```\r\n", "updated_at": "2019-03-21T15:14:46Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/475270863", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-475270863", "created_at": "2019-03-21T15:14:46Z", "id": 475270863, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NTI3MDg2Mw=="}, {"user": {"following_url": "https://api.github.com/users/petrutlucian94/following{/other_user}", "url": "https://api.github.com/users/petrutlucian94", "site_admin": false, "gists_url": "https://api.github.com/users/petrutlucian94/gists{/gist_id}", "node_id": "MDQ6VXNlcjQ1NzA3NDk=", "starred_url": "https://api.github.com/users/petrutlucian94/starred{/owner}{/repo}", "gravatar_id": "", "id": 4570749, "events_url": "https://api.github.com/users/petrutlucian94/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/4570749?v=4", "login": "petrutlucian94", "repos_url": "https://api.github.com/users/petrutlucian94/repos", "subscriptions_url": "https://api.github.com/users/petrutlucian94/subscriptions", "followers_url": "https://api.github.com/users/petrutlucian94/followers", "html_url": "https://github.com/petrutlucian94", "received_events_url": "https://api.github.com/users/petrutlucian94/received_events", "type": "User", "organizations_url": "https://api.github.com/users/petrutlucian94/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> A single device can have multiple PIO/MMIO ranges, e.g. PCI can have multiple BARs\r\n\r\nTo keep it simple and stick with the current interfaces, one idea would be to just register each of those ranges separately, basically having multiple references to the same device in the bus device tree.", "updated_at": "2019-03-26T08:31:29Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/476523040", "author_association": "NONE", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-476523040", "created_at": "2019-03-26T08:31:29Z", "id": 476523040, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NjUyMzA0MA=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "Exactly this works with current Firecracker or CrosVM. To me, the existing PIO/MMIO bus is kind of \u2018low-level\u2019 thing and not the best suitable thing to represent the bus in a device tree. The \u2018high-level\u2019 bus can be a real world bus like ISA/PCI bus, or just a logic bus(like sysbus in QEMU) which groups the devices together. This is not only for perfect display of a device tree, it can be useful when more functionalities being added. Taking ACPI AML code generation for example: we need iterate all the devices in one bus to invoke device specific AML code generation method. In current code it would be hard.\r\n\r\nThis is not to say existing PIO/MMIO bus is not necessary, we still need it for read/write dispatch from hypervisor. But they will just keep their 'low-level' role and will be restricted internally to DeviceManger and other part of the code will interact with them through DeviceManager API.\r\n", "updated_at": "2019-03-26T13:25:06Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/476632014", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-476632014", "created_at": "2019-03-26T13:25:06Z", "id": 476632014, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NjYzMjAxNA=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> * A Bus trait\r\nThe current firecracker and crosvm Bus implementation uses a binary tree to represent a devices bus, but we may want to allow for more flexibility by providing a trait and then having a binary tree implementation of this trait.\r\n\r\nHi Sameo,\r\n       I have some questions about the Bus trait,\r\n       1) How to support devices with multiple address spaces? For example, PCI has IO, MMIO and CFG address space.\r\n       2) Do we need methods to enumerate all devices on a bus?\r\n       3) Do we need bus specific device-IDs to identify a device?", "updated_at": "2019-03-27T11:25:09Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/477106533", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-477106533", "created_at": "2019-03-27T11:25:09Z", "id": 477106533, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3NzEwNjUzMw=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@chao-p I prefer the first design, I think we need to explicitly represent a bus and have an easy way to link a device to its parent bus, for e.g. building accurate hardware description tables.\r\nI feel the assumption that a Bus is a `Device` itself and an `Iterator` of `Device` as well is the right approach:\r\n\r\n```Rust\r\npub trait Bus: Device + Iterator {\r\n}\r\n```\r\n\r\nAbout the `DeviceManager`: It should abstract the `Device` and `Bus` registration by providing two main entry points: `register_bus` and `register_device()`\r\n\r\n```Rust\r\nimpl DeviceManager {\r\n[...]\r\n   /// Register a Bus into the machine topology, and optionally link it back to a parent bus\r\n   fn register_bus(bus: Arc<Mutex<Bus>>, parent: Option<Bus>) -> Result<()> {\r\n   [...]\r\n   }\r\n\r\n   /// Register a Device into the machine topology, and optionally link it back to a parent bus.\r\n   fn register_device(device: Arc<Mutex<Device>>, parent: Option<Bus>) -> Result<()> {\r\n   [...]\r\n   }\r\n}\r\n```\r\n\r\nThe missing piece for this to work is an overall resource manager. crosvm has something similar, i.e. a single entity that is responsible for handling resources allocation and conflicts. Resources in that context can be: Address ranges for several kinds of memory (RAM, MMIO), IO ports and IRQs.\r\n\r\nA `Device` should be built with a set of resources it needs: Vectors of PIO and MMIO ranges, and IRQs. `register_device` and `register_bus` get that list of resources from the device itself and calls into the resource allocator for reserving those ranges (And possibly getting an error in case there's a conflict and overlap is not allowed). The memory model should also call into the resource allocator when e.g assigning the guest with RAM regions.\r\n\r\nWith such resource allocator in place, pseudo code for registering e.g. a virtio MMIO and a PCI device would look like:\r\n\r\n```Rust\r\nlet device_mgr = DeviceManager::new();\r\nlet virtio_bus = VirtioBus::new();\r\nlet pci_bus = PCIBus::new();\r\ndevice_mgr.register_bus(virtio_bus, None);\r\ndevice_mgr.register_bus(pci_bus, None);\r\n\r\nlet virtio_dev = VirtioMMIO::new();\r\nlet pci_dev = DummyPCI::new();\r\ndevice_mgr.register_device(virtio_net, Some(virtio_bus));\r\ndevice_mgr.register_device(pci_dev, Some(pci_bus))\r\n```\r\n\r\nThe two `register_device` lines would imply that the `DeviceManager`, for each device does:\r\n\r\n* Reserve the amount of needed resources described by the `Device` (bus or device)\r\n* Insert the `Device` in the device topology or the `Bus` in the bus topology. \r\n* Map devices and buses to their set of resources\r\n* Add the `Device` to the parent `Bus`\r\n\r\nAnd to answer @jiangliu:\r\n\r\n- The `DeviceManager` implementation should provide a method for enumerating all devices in a bus.\r\n- It should also provide a method for decoding an address into a `Option<Bus>` and a `Device`.\r\n- I'm not sure why we'd need to have bus specific device IDs. Any use case you have in mind for this?\r\n\r\ncc @rbradford @bonzini ", "updated_at": "2019-04-01T17:42:49Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478675711", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478675711", "created_at": "2019-04-01T17:42:49Z", "id": 478675711, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODY3NTcxMQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "I agree with @sameo, with just a couple notes:\r\n\r\n* I don't really like having Mutex in the prototypes. I prefer having just `Arc<dyn Device>` and then the VirtioDevice can implement Device and hide its implementation beneath a `Mutex<VirtioDeviceImpl>`.\r\n\r\n* The Bus is not an iterator, though it could have an `iter()` method to return one.\r\n\r\nFor devices with RAM BARs, do we need some kind of interface between the Bus and/or Device on one side and the GuestMemory implementation? Currently in Firecracker the GuestMemory is the sole source of KVM memory regions, would it make sense to have instead some kind of publish/subscribe, where both Devices and GuestMemory publish their RAM resources and KVM subscribes to retrieve changes?", "updated_at": "2019-04-02T07:35:34Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478880297", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478880297", "created_at": "2019-04-02T07:35:34Z", "id": 478880297, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODg4MDI5Nw=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> A `Device` should be built with a set of resources it needs: Vectors of PIO and MMIO ranges, and IRQs. `register_device` and `register_bus` get that list of resources from the device itself and calls into the resource allocator for reserving those ranges\r\n\r\n@sameo This places an assumption that all the resources are known at 'register' time, this is not true for some devices as far as I can tell. \r\n\r\nMy design to give device itself the ability to allocate device resources with alloc_pio/mmio/irq and register_pio/mmio is by intention and can provide some level of flexibility: \r\n- it can use these interfaces in init() to register resources that known at 'init' time.\r\n- it can also register resources at runtime with the same interfaces, when necessary.\r\n", "updated_at": "2019-04-02T07:47:04Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478883779", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478883779", "created_at": "2019-04-02T07:47:04Z", "id": 478883779, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODg4Mzc3OQ=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@bonzini\r\n> * I don't really like having Mutex in the prototypes. I prefer having just `Arc<dyn Device>` and then the VirtioDevice can implement Device and hide its implementation beneath a `Mutex<VirtioDeviceImpl>`.\r\n\r\nYes, I like `Arc<dyn Device>` as well.\r\n\r\n> * The Bus is not an iterator, though it could have an `iter()` method to return one.\r\n\r\nCurrently we are thinking Bus as a collection of devices, this is not too appropriate exactly. What we really need is providing the ability to traverse all the devices under a bus.\r\n ", "updated_at": "2019-04-02T08:09:35Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478890714", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478890714", "created_at": "2019-04-02T08:09:35Z", "id": 478890714, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODg5MDcxNA=="}, {"user": {"following_url": "https://api.github.com/users/rbradford/following{/other_user}", "url": "https://api.github.com/users/rbradford", "site_admin": false, "gists_url": "https://api.github.com/users/rbradford/gists{/gist_id}", "node_id": "MDQ6VXNlcjU4ODIyNA==", "starred_url": "https://api.github.com/users/rbradford/starred{/owner}{/repo}", "gravatar_id": "", "id": 588224, "events_url": "https://api.github.com/users/rbradford/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/588224?v=4", "login": "rbradford", "repos_url": "https://api.github.com/users/rbradford/repos", "subscriptions_url": "https://api.github.com/users/rbradford/subscriptions", "followers_url": "https://api.github.com/users/rbradford/followers", "html_url": "https://github.com/rbradford", "received_events_url": "https://api.github.com/users/rbradford/received_events", "type": "User", "organizations_url": "https://api.github.com/users/rbradford/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> @sameo This places an assumption that all the resources are known at 'register' time, this is not true for some devices as far as I can tell.\r\n\r\n@chao-p Could you elaborate on that? What device (type) do you know of that need to dynamically assign themselves the ranges and that can't be handled by having an initial large range. Generally these resources you're talk about aren't particularly limited.", "updated_at": "2019-04-02T08:29:58Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478897239", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478897239", "created_at": "2019-04-02T08:29:58Z", "id": 478897239, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODg5NzIzOQ=="}, {"user": {"following_url": "https://api.github.com/users/rbradford/following{/other_user}", "url": "https://api.github.com/users/rbradford", "site_admin": false, "gists_url": "https://api.github.com/users/rbradford/gists{/gist_id}", "node_id": "MDQ6VXNlcjU4ODIyNA==", "starred_url": "https://api.github.com/users/rbradford/starred{/owner}{/repo}", "gravatar_id": "", "id": 588224, "events_url": "https://api.github.com/users/rbradford/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/588224?v=4", "login": "rbradford", "repos_url": "https://api.github.com/users/rbradford/repos", "subscriptions_url": "https://api.github.com/users/rbradford/subscriptions", "followers_url": "https://api.github.com/users/rbradford/followers", "html_url": "https://github.com/rbradford", "received_events_url": "https://api.github.com/users/rbradford/received_events", "type": "User", "organizations_url": "https://api.github.com/users/rbradford/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> Currently in Firecracker the GuestMemory is the sole source of KVM memory regions, would it make sense to have instead some kind of publish/subscribe, where both Devices and GuestMemory publish their RAM resources and KVM subscribes to retrieve changes?\r\n\r\nThis might also help address @sboeuf virtio-fs DAX related things.", "updated_at": "2019-04-02T08:30:53Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478897547", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478897547", "created_at": "2019-04-02T08:30:53Z", "id": 478897547, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODg5NzU0Nw=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> * I don't really like having Mutex in the prototypes. I prefer having just `Arc<dyn Device>` and then the VirtioDevice can implement Device and hide its implementation beneath a `Mutex<VirtioDeviceImpl>`.\r\n>\r\nMakes sense.\r\n\r\n\r\n> Would it make sense to have instead some kind of publish/subscribe, where both Devices and GuestMemory publish their RAM resources and KVM subscribes to retrieve changes?\r\n\r\nI may be misunderstanding your point, but I guess this could be done by GuestMemory and Devices publishing their RAM resouces and the resource allocator would be listening to those changes and updating KVM accordingly.\r\n", "updated_at": "2019-04-02T09:29:37Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478917916", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478917916", "created_at": "2019-04-02T09:29:37Z", "id": 478917916, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODkxNzkxNg=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> > @sameo This places an assumption that all the resources are known at 'register' time, this is not true for some devices as far as I can tell.\r\n> \r\n> @chao-p Could you elaborate on that? What device (type) do you know of that need to dynamically assign themselves the ranges and that can't be handled by having an initial large range. Generally these resources you're talk about aren't particularly limited.\r\n\r\nIn real world devices, there are some of them. Usually the layout/enabling status of the IO ranges can be re-configured by writing to certain configuration registers. PCIEXBAR/PAM/SMRAM are such of examples, they are implemented in QEMU but I don't think we are interested in enabling them.\r\n\r\nOne example I can think that may potentially impact us is PCI 'Resizable BAR Capability',  if we support passthru then we need do something for that, either disable the capability or add resizing support.\r\n\r\nNot sure if any one knows more example. But if those are just really some corner cases that we don't want to support, then just ignore this and a table-driven design for resource register is much clear.", "updated_at": "2019-04-02T11:38:45Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/478957906", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-478957906", "created_at": "2019-04-02T11:38:45Z", "id": 478957906, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3ODk1NzkwNg=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "I think we all agree this crate is needed, obviously. I'll go ahead and create a `vm-device` crate.", "updated_at": "2019-04-03T08:55:27Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/479401169", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-479401169", "created_at": "2019-04-03T08:55:27Z", "id": 479401169, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTQwMTE2OQ=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@chao-p \r\n> One example I can think that may potentially impact us is PCI 'Resizable BAR Capability', if we support passthru then we need do something for that, either disable the capability or add resizing support.\r\n\r\nI assume this is mostly useful for large BAR devices that need some more space once their on 64 bits? GPUs for example?\r\n\r\nI think the current proposal could be expanded to support direct allocation requests, when the need to support such feature arise?", "updated_at": "2019-04-03T13:52:25Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/479498613", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-479498613", "created_at": "2019-04-03T13:52:16Z", "id": 479498613, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTQ5ODYxMw=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> I think the current proposal could be expanded to support direct allocation requests, when the need to support such feature arise?\r\n\r\n@sameo Make sense. It can be easily expanded, without breaking the existing APIs.", "updated_at": "2019-04-03T14:50:21Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/479523137", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-479523137", "created_at": "2019-04-03T14:50:21Z", "id": 479523137, "node_id": "MDEyOklzc3VlQ29tbWVudDQ3OTUyMzEzNw=="}, {"user": {"following_url": "https://api.github.com/users/sboeuf/following{/other_user}", "url": "https://api.github.com/users/sboeuf", "site_admin": false, "gists_url": "https://api.github.com/users/sboeuf/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODkwNDEz", "starred_url": "https://api.github.com/users/sboeuf/starred{/owner}{/repo}", "gravatar_id": "", "id": 22890413, "events_url": "https://api.github.com/users/sboeuf/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/22890413?v=4", "login": "sboeuf", "repos_url": "https://api.github.com/users/sboeuf/repos", "subscriptions_url": "https://api.github.com/users/sboeuf/subscriptions", "followers_url": "https://api.github.com/users/sboeuf/followers", "html_url": "https://github.com/sboeuf", "received_events_url": "https://api.github.com/users/sboeuf/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sboeuf/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "Sorry for being late to the party here. Here are my inputs:\r\n\r\n@chao-p \r\n>>@sameo This places an assumption that all the resources are known at 'register' time, this is not true for some devices as far as I can tell.\r\n\r\n> Not sure if any one knows more example. But if those are just really some corner cases that we don't want to support, then just ignore this and a table-driven design for resource register is much clear.\r\n\r\nCrosvm needs to find dynamically some free ranges to allocate shared regions asked by the guest. This is part of the `virtio-wayland` device, where no shared region is allocated up front, but instead at runtime, leaving the guest driver asking about new shared memory to be allocated.\r\n\r\n`virtio-fs` can work without this dynamic allocation since the user is the one picking up the size of the shared memory at the time the VM is started. And this size is communicated to the guest driver through the PCI BARs, hence \"register\" time would be fine.\r\n\r\n@sameo  \r\n>The missing piece for this to work is an overall resource manager. crosvm has something similar, i.e. a single entity that is responsible for handling resources allocation and conflicts.\r\n\r\n@bonzini\r\n>would it make sense to have instead some kind of publish/subscribe, where both Devices and GuestMemory publish their RAM resources and KVM subscribes to retrieve changes?\r\n\r\nWe definitely need this. It's called the `SystemAllocator` in case of Crosvm, and it is the central entity keeping track of every memory region being used. But for Crosvm, this is not the one interacting with KVM, as the `mmap()` returning the host virtual address (if we're talking about guest RAM or some shared memory region) has to happen before we can issue the KVM call `KVM_SET_USER_MEMORY_REGION`. So the question is, do we want to merge all that under a more generic entity, and if we do so, we might have some strong dependencies between the `vm_memory` crate and this `allocator` entity.\r\nI would like to hear Crosvm folks opinion on this. /cc @zachreizner \r\n\r\nNow if we look at the Firecracker model, since they don't support any complex use case regarding device memory, they have a much simplified model that does not require such allocator. Therefore, either they would agree to include this allocator as part of their code, which would simplify the case where the allocator would be tightly coupled to the memory model, OR they don't, and in this case we need to come up with a solution decoupled from the allocator.\r\nWe should make clear from a community standpoint if we think that it's okay to run without a centralized allocator. /cc @andreeaflorescu @alexandruag \r\n\r\n@sameo @chao-p @bonzini @jiangliu \r\nOne global comment about the vm-device crate with `Bus`, `Device` and `DeviceManager` traits. Let's make sure we're not re-inventing the wheel here, and rely heavily on what's already there in Crosvm and Firecracker.\r\nThe success of rust-vmm will be its adoption by already existing project (again Crosvm and Firecracker), and unless we come up with justification why some designs might not fit all future needs, then we should simply pull what they have. Starting from something existing and going through the flaws to justify some design changes might be a good way to decide what is going to be the right design.", "updated_at": "2019-04-04T21:16:59Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/480067083", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-480067083", "created_at": "2019-04-04T21:16:59Z", "id": 480067083, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDA2NzA4Mw=="}, {"user": {"following_url": "https://api.github.com/users/sboeuf/following{/other_user}", "url": "https://api.github.com/users/sboeuf", "site_admin": false, "gists_url": "https://api.github.com/users/sboeuf/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODkwNDEz", "starred_url": "https://api.github.com/users/sboeuf/starred{/owner}{/repo}", "gravatar_id": "", "id": 22890413, "events_url": "https://api.github.com/users/sboeuf/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/22890413?v=4", "login": "sboeuf", "repos_url": "https://api.github.com/users/sboeuf/repos", "subscriptions_url": "https://api.github.com/users/sboeuf/subscriptions", "followers_url": "https://api.github.com/users/sboeuf/followers", "html_url": "https://github.com/sboeuf", "received_events_url": "https://api.github.com/users/sboeuf/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sboeuf/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "Actually the more I look into Crosvm, the more I think we need to come up with strong reasons if we want rust-vmm to diverge from their model there, as it handles things pretty cleanly.\r\n\r\nThe common base between Firecracker and Crosvm is the `Bus` structure with the trait `BusDevice`, which is implemented by any device such as `cmos`, `pci`, `serial`, `mmio`. The methods from `Bus` differ slightly but the idea is the same, the `Bus` is a very generic component that should be either `PIO` or `MMIO`, what they both call `io_bus` or `mmio_bus`.\r\nThis is very decoupled from any other piece of code as it simply maintains the list of devices on each bus. I think what they call buses here could be seen as two separate address spaces.\r\nBut the point is to consider that each device falls back under one of the two buses or even both (case for PCI for instance).\r\n\r\nSo now, the part about who is picking those address ranges for the devices that we're trying to create. Well the way it's done by Crosvm for the `io_bus` is very hardcoded, but I think everything should go through a structure `MemoryManager` (the allocator in case of Crosvm) keeping track of every single piece of memory. The same way we have two different buses, we would need two different `MemoryManager` instances for both `PIO` and `MMIO`.\r\nEach device, such as `cmos` or any `virtio-pci`, would be created, implementing the `BusDevice` trait, and would use any of those two `MemoryManager` to get available address ranges on one of the address space they are interested in. After they would get the result, they would feed this into one of the two buses.\r\n\r\nThings might still be a bit confused in my mind, but I think the main point I'm trying to make is that I don't want to see too many abstractions layers for the sake of creating abstractions layers, when it seems that addressable memory spaces can simply be split between MMIO and PIO.", "updated_at": "2019-04-05T07:28:12Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/480176189", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-480176189", "created_at": "2019-04-05T07:28:12Z", "id": 480176189, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDE3NjE4OQ=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "I totally agree with using the Crosvm code. Whether to put it in vm-device or vm-memory is up to the people doing the \"extraction\".", "updated_at": "2019-04-05T07:35:33Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/480178012", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-480178012", "created_at": "2019-04-05T07:35:33Z", "id": 480178012, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDE3ODAxMg=="}, {"user": {"following_url": "https://api.github.com/users/sameo/following{/other_user}", "url": "https://api.github.com/users/sameo", "site_admin": false, "gists_url": "https://api.github.com/users/sameo/gists{/gist_id}", "node_id": "MDQ6VXNlcjEwNDM4NjM=", "starred_url": "https://api.github.com/users/sameo/starred{/owner}{/repo}", "gravatar_id": "", "id": 1043863, "events_url": "https://api.github.com/users/sameo/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/1043863?v=4", "login": "sameo", "repos_url": "https://api.github.com/users/sameo/repos", "subscriptions_url": "https://api.github.com/users/sameo/subscriptions", "followers_url": "https://api.github.com/users/sameo/followers", "html_url": "https://github.com/sameo", "received_events_url": "https://api.github.com/users/sameo/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sameo/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@sboeuf Thanks for the input. A few comments from me:\r\n\r\n* The only real trait that we'd need is the `Device` one. A `Bus` could implement the `Device` trait. And `DeviceManager` would not be a trait.\r\n\r\n* The system allocator is needed, except for cases where the memory model is immutable and static (Firecracker). And it should look a lot like the crosvm one, yes. That's what I called the resource manager but it's essentially crosvm's system allocator. Should it be part of vm-device? Or vm-memory? Or a separate crate? I'd prefer for it to be part of vm-device but that's just my opinion.\r\n\r\n* The `DeviceManager` sits between the system allocator and `Device` themselves. The former registers against the latter, asking for PIO and MMIO ranges, and interrupts. The device manager keeps track of the machine topology and proxies the system allocator calls for the Devices. It's not an abstraction layer per se, but rather a management one. It's probably a good thing for a VMM to have an extensive view of the topology of the machine it's defining (for introspection, hardware table generation, etc).\r\n\r\nSo I think this proposal does not really add additional abstraction layers, but plans on using crosvm's system allocator to keep track of the address spaces usage and allocation and adding a device manager to build a consistent view of the machine topology and device/bus dependencies.\r\n", "updated_at": "2019-04-05T11:53:34Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/480248190", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-480248190", "created_at": "2019-04-05T11:53:34Z", "id": 480248190, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MDI0ODE5MA=="}, {"user": {"following_url": "https://api.github.com/users/sboeuf/following{/other_user}", "url": "https://api.github.com/users/sboeuf", "site_admin": false, "gists_url": "https://api.github.com/users/sboeuf/gists{/gist_id}", "node_id": "MDQ6VXNlcjIyODkwNDEz", "starred_url": "https://api.github.com/users/sboeuf/starred{/owner}{/repo}", "gravatar_id": "", "id": 22890413, "events_url": "https://api.github.com/users/sboeuf/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/22890413?v=4", "login": "sboeuf", "repos_url": "https://api.github.com/users/sboeuf/repos", "subscriptions_url": "https://api.github.com/users/sboeuf/subscriptions", "followers_url": "https://api.github.com/users/sboeuf/followers", "html_url": "https://github.com/sboeuf", "received_events_url": "https://api.github.com/users/sboeuf/received_events", "type": "User", "organizations_url": "https://api.github.com/users/sboeuf/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@sameo \r\n>The only real trait that we'd need is the Device one. A Bus could implement the Device trait. And DeviceManager would not be a trait.\r\n\r\nSounds good.\r\n\r\n>The system allocator is needed, except for cases where the memory model is immutable and static (Firecracker). And it should look a lot like the crosvm one, yes. That's what I called the resource manager but it's essentially crosvm's system allocator. Should it be part of vm-device? Or vm-memory? Or a separate crate? I'd prefer for it to be part of vm-device but that's just my opinion.\r\n\r\n`vm-device` is one of the components using this system allocator, but not the only one, which makes a bit weird to have it defined in the `vm-device` crate.\r\n\r\n>It's not an abstraction layer per se, but rather a management one. It's probably a good thing for a VMM to have an extensive view of the topology of the machine it's defining (for introspection, hardware table generation, etc).\r\n\r\nThat is true, and this is the part I was missing, thanks for pointing me to this. Simple VMM such as Firecracker don't need an extensive view of the system since it is fairly simple, but other might need it for more complex use cases such as `vhost-user` and memory hotplug. That being said, we need to make sure the solution can be reused by FC. Crosvm should be a simple matter of refactoring since they already have this concept in place.\r\n\r\n>So I think this proposal does not really add additional abstraction layers, but plans on using crosvm's system allocator to keep track of the address spaces usage and allocation and adding a device manager to build a consistent view of the machine topology and device/bus dependencies.\r\n\r\nThanks for the clarification, it helps a lot :+1: ", "updated_at": "2019-04-10T18:01:46Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/481798660", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-481798660", "created_at": "2019-04-10T18:01:46Z", "id": 481798660, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4MTc5ODY2MA=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> > * I don't really like having Mutex in the prototypes. I prefer having just `Arc<dyn Device>` and then the VirtioDevice can implement Device and hide its implementation beneath a `Mutex<VirtioDeviceImpl>`.\r\n> \r\n> Makes sense.\r\n> \r\n> > Would it make sense to have instead some kind of publish/subscribe, where both Devices and GuestMemory publish their RAM resources and KVM subscribes to retrieve changes?\r\n> \r\n> I may be misunderstanding your point, but I guess this could be done by GuestMemory and Devices publishing their RAM resouces and the resource allocator would be listening to those changes and updating KVM accordingly.\r\n\r\nHow about using the resource allocator in the device manager to manage guest physical memory too?\r\nWe may treat guest physical memory as a special type of system device, and allocate GPA regions for guest memory from a system address allocator. On the other hand, vm_memory just provides methods to access those memory devices.", "updated_at": "2019-05-05T23:10:39Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/489421715", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-489421715", "created_at": "2019-05-05T12:25:27Z", "id": 489421715, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQyMTcxNQ=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> @sboeuf Thanks for the input. A few comments from me:\r\n> \r\n> * The only real trait that we'd need is the `Device` one. A `Bus` could implement the `Device` trait. And `DeviceManager` would not be a trait.\r\n> * The system allocator is needed, except for cases where the memory model is immutable and static (Firecracker). And it should look a lot like the crosvm one, yes. That's what I called the resource manager but it's essentially crosvm's system allocator. Should it be part of vm-device? Or vm-memory? Or a separate crate? I'd prefer for it to be part of vm-device but that's just my opinion.\r\nI prefer it to be part of vm-device too. vm-memory should just provide mechanism to access memory device, and memory device is a type of device too.\r\n> * The `DeviceManager` sits between the system allocator and `Device` themselves. The former registers against the latter, asking for PIO and MMIO ranges, and interrupts. The device manager keeps track of the machine topology and proxies the system allocator calls for the Devices. It's not an abstraction layer per se, but rather a management one. It's probably a good thing for a VMM to have an extensive view of the topology of the machine it's defining (for introspection, hardware table generation, etc).\r\n> \r\n> So I think this proposal does not really add additional abstraction layers, but plans on using crosvm's system allocator to keep track of the address spaces usage and allocation and adding a device manager to build a consistent view of the machine topology and device/bus dependencies.\r\nSeems  it would be clear to distinguish between bus address and resource address.\r\n1) The device manager provides interfaces to find a device by resource addresses(such as MMIO, PIO, irq addresses). A device may be addressed by different address ranges of the same resource type, or addresses by different address ranges of different resource types.\r\n2) A bus provide methods to iterator over all devices on the bus or  find a device by bus address(such as PCI device id).\r\n\r\n", "updated_at": "2019-05-05T12:40:09Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/489422795", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-489422795", "created_at": "2019-05-05T12:40:09Z", "id": 489422795, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQyMjc5NQ=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> @sameo\r\n> \r\n> > The only real trait that we'd need is the Device one. A Bus could implement the Device trait. And DeviceManager would not be a trait.\r\n> \r\n> Sounds good.\r\n> \r\n> > The system allocator is needed, except for cases where the memory model is immutable and static (Firecracker). And it should look a lot like the crosvm one, yes. That's what I called the resource manager but it's essentially crosvm's system allocator. Should it be part of vm-device? Or vm-memory? Or a separate crate? I'd prefer for it to be part of vm-device but that's just my opinion.\r\n> \r\n\r\n\r\n`vm-device` is one of the components using this system allocator, but not the only one, which makes a bit weird to have it defined in the `vm-device` crate.\r\nSounds like calling for a vm-resource-manager crate:)\r\nActually I think the vm-memory crate should be treated as a resource accessor instead of a resource manager. Once I tried to introduce a simple resource manager into the vm-memory, but it would be better to have a global resource manager out of the vm-memory crate.\r\n> \r\n> > It's not an abstraction layer per se, but rather a management one. It's probably a good thing for a VMM to have an extensive view of the topology of the machine it's defining (for introspection, hardware table generation, etc).\r\n> \r\n> That is true, and this is the part I was missing, thanks for pointing me to this. Simple VMM such as Firecracker don't need an extensive view of the system since it is fairly simple, but other might need it for more complex use cases such as `vhost-user` and memory hotplug. That being said, we need to make sure the solution can be reused by FC. Crosvm should be a simple matter of refactoring since they already have this concept in place.\r\n> \r\n> > So I think this proposal does not really add additional abstraction layers, but plans on using crosvm's system allocator to keep track of the address spaces usage and allocation and adding a device manager to build a consistent view of the machine topology and device/bus dependencies.\r\n> \r\n> Thanks for the clarification, it helps a lot \ud83d\udc4d\r\n\r\n", "updated_at": "2019-05-05T23:09:36Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/489423166", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-489423166", "created_at": "2019-05-05T12:45:13Z", "id": 489423166, "node_id": "MDEyOklzc3VlQ29tbWVudDQ4OTQyMzE2Ng=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "Repository created: https://github.com/rust-vmm/vm-device", "updated_at": "2019-05-20T10:53:50Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/493937116", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-493937116", "created_at": "2019-05-20T10:53:50Z", "id": 493937116, "node_id": "MDEyOklzc3VlQ29tbWVudDQ5MzkzNzExNg=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "I am coming really really late to the party, but only after I saw the PR I understood the implications of `vm-allocator`.\r\n\r\nAs some people pointed out, the devices in Firecracker are static and do not need a complex `SystemAllocator` to handle the memory regions/other resources. With that in mind, I would propose to have the `vm-device` independent of the implementation of the `SystemAllocator`. I think it also makes sense for VMMs with dynamic devices because devices don't necessarily need to know about the allocated regions of other devices, hence a reference to `SystemAllocator` should not be needed by the `DeviceManager`.\r\n\r\nFrom a really high-level point of view, I would see the VMM doing the following operations related to devices and allocating:\r\n- initialize a system allocator\r\n- initialize the device manager\r\n- allocate memory/addresses/irq/other resources\r\n- create a device\r\n- add the device to the device manager and specify the resources that the device is using\r\n\r\n```rust\r\nuse vm_allocator::{IdAllocator, SystemAllocator};\r\nuse vm_device::DeviceManager;\r\n\r\nvmm = Vmm::new();\r\n// Other initialization related to the vmm\r\n....\r\n// Initialize the SystemAllocator and add Resource Allocator to it.\r\nlet system_allocator = SystemAllocator::new();\r\n\r\n// Let's say we want a IRQ numbers allocator and a MMIO regions allocator.\r\n\r\n// The IRQ allocator is basically just allocating numbers (u32) from 0 to 15, so we can use a basic IdAllocator.\r\nlet irq_allocator = IdAllocator::new(0, 15);\r\n// Let the system allocator know we have a new allocator it manages.\r\nsystem_allocator.add(\"irq_allocator\", irq_allocator);\r\n\r\n// Let's also create a MMIO allocator. This one is handling addresses, so we can use the AddressAllocator.\r\nlet mmio_range_allocator = AddressAllocator(0xd000_0000, 0x4000);\r\nsystem_allocator.add(\"mmio_allocator\", mmio_range_allocator);\r\n\r\n// Fun part begins, we want to add a new device to the device manager.\r\nlet device_manager = DeviceManager::new(...);\r\n\r\n// A Virtio Block device backed by MMIO needs an IRQ, so we need 2 allocations: one from irq_allocator and one from mmio_range_allocator.\r\nlet irq =  system_allocator.allocate(\"irq_allocator\").unwrap();\r\nlet mmio_range = system_allocator.allocate(\"mmio_range_allocator).unwrap();\r\n\r\nlet virtio_block_device = VirtioBlockDevice::new(....);\r\n// register device receives as parameter something that implements `Device` and the resources needed by that device.\r\ndevice_manager.register_device(virtio_device, &[irq, mmio_range]);\r\n````\r\n\r\nI wrote a dummy vm-allocator interface and it has some more details on how I see this being used by VMMs: https://github.com/andreeaflorescu/vm-allocator", "updated_at": "2019-07-15T12:07:45Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/511375675", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-511375675", "created_at": "2019-07-15T12:07:45Z", "id": 511375675, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTM3NTY3NQ=="}, {"user": {"following_url": "https://api.github.com/users/liujing2/following{/other_user}", "url": "https://api.github.com/users/liujing2", "site_admin": false, "gists_url": "https://api.github.com/users/liujing2/gists{/gist_id}", "node_id": "MDQ6VXNlcjM5Njg0NjQ5", "starred_url": "https://api.github.com/users/liujing2/starred{/owner}{/repo}", "gravatar_id": "", "id": 39684649, "events_url": "https://api.github.com/users/liujing2/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/39684649?v=4", "login": "liujing2", "repos_url": "https://api.github.com/users/liujing2/repos", "subscriptions_url": "https://api.github.com/users/liujing2/subscriptions", "followers_url": "https://api.github.com/users/liujing2/followers", "html_url": "https://github.com/liujing2", "received_events_url": "https://api.github.com/users/liujing2/received_events", "type": "User", "organizations_url": "https://api.github.com/users/liujing2/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "Trying to list some big differences between very simple vmm (like firecracker) and general vmm request after some talk with @andreeaflorescu . If there's something misunderstanding, please correct me. :)\r\n\r\nvm-device:\r\n- Key to decouple with vm-allocator: who is better responsible for each device resource allocation and free? VMM or DeviceManager?\r\n\r\nvm-allocator:\r\n- All resources need to be managed (e.g. by SystemAllocator), recording which region is used and for what in general vmm. Simple vmm would not to have this.\r\n- Each resource are thread safe. Who protecting this depends. e.g. `Arc<Mutex<IdAllocator>>` in SystemAllocator or VMM.\r\n- Can provide two level APIs for simple vmm like firecraker and normal one: System level APIs and low level APIs on each resource type.\r\n", "updated_at": "2019-07-15T12:35:49Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/511384046", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-511384046", "created_at": "2019-07-15T12:35:49Z", "id": 511384046, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTM4NDA0Ng=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "My proposal was to have the `SystemAllocator` implemented in each VMM. But the implementation of the `SystemAllocator` would be rather trivial as it would only have wrapper functions to call into other allocators that are already defined in `vm-allocator`. With this approach you wouldn't have to worry about providing two implementations for the SystemAllocator: one that it's thread safe and one that is not. The SystemAllocator is basically just a structure with a list of resources it manages. If the resource allocators can be called from multiple threads, each resource allocator is wrapped in a Arc<Mutex>. This is what I tried to exemplify here: https://github.com/andreeaflorescu/vm-allocator/blob/b3ca45137fd145c9cb7773fd77648ba26173a7ba/src/lib.rs#L56\r\n\r\nFor example if we were to have a SystemAllocator in Firecracker, it would look something like this:\r\n```rust\r\n  struct SystemAllocator {\r\n        irq: IdAllocator,\r\n        device_id: IdAllocator,\r\n}\r\n\r\nimpl SystemAllocator {\r\n    pub fn new() -> Self{\r\n         SystemAllocator {\r\n                 irq: IdAllocator::new(0, 15),\r\n                device_id: IdAllocator::new(100, 200),\r\n         }\r\n    }\r\n    pub fn allocate_irq(&mut self) -> Result<u32>{\r\n        /// IRQ are actually mapped with IdAllocator, so we just call the allocate function implemented in vm-allocator::IdAllocator\r\n       let irq_as_id = self.irq.allocate();\r\n       /// The value of the IRQ is wrapped in an Id; to get the number we can use `.0`\r\n       irq_as_id.0\r\n    }\r\n\r\n    .....\r\n}\r\n```\r\nThis needs to be extended with a MMIO Allocator.\r\n", "updated_at": "2019-07-15T13:31:32Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/511403087", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-511403087", "created_at": "2019-07-15T13:31:32Z", "id": 511403087, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTQwMzA4Nw=="}, {"user": {"following_url": "https://api.github.com/users/bonzini/following{/other_user}", "url": "https://api.github.com/users/bonzini", "site_admin": false, "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "node_id": "MDQ6VXNlcjQyMDgy", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "gravatar_id": "", "id": 42082, "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "avatar_url": "https://avatars2.githubusercontent.com/u/42082?v=4", "login": "bonzini", "repos_url": "https://api.github.com/users/bonzini/repos", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "followers_url": "https://api.github.com/users/bonzini/followers", "html_url": "https://github.com/bonzini", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "organizations_url": "https://api.github.com/users/bonzini/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> a reference to SystemAllocator should not be needed by the DeviceManager.\r\n\r\nI agree, also because you may have a VMM that doesn't need a SystemAllocator at all if the SystemAllocator's job is done by the firmware.", "updated_at": "2019-07-16T14:03:29Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/511829939", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-511829939", "created_at": "2019-07-16T14:03:29Z", "id": 511829939, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMTgyOTkzOQ=="}, {"user": {"following_url": "https://api.github.com/users/liujing2/following{/other_user}", "url": "https://api.github.com/users/liujing2", "site_admin": false, "gists_url": "https://api.github.com/users/liujing2/gists{/gist_id}", "node_id": "MDQ6VXNlcjM5Njg0NjQ5", "starred_url": "https://api.github.com/users/liujing2/starred{/owner}{/repo}", "gravatar_id": "", "id": 39684649, "events_url": "https://api.github.com/users/liujing2/events{/privacy}", "avatar_url": "https://avatars1.githubusercontent.com/u/39684649?v=4", "login": "liujing2", "repos_url": "https://api.github.com/users/liujing2/repos", "subscriptions_url": "https://api.github.com/users/liujing2/subscriptions", "followers_url": "https://api.github.com/users/liujing2/followers", "html_url": "https://github.com/liujing2", "received_events_url": "https://api.github.com/users/liujing2/received_events", "type": "User", "organizations_url": "https://api.github.com/users/liujing2/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> > a reference to SystemAllocator should not be needed by the DeviceManager.\r\n> \r\n> I agree, also because you may have a VMM that doesn't need a SystemAllocator at all if the SystemAllocator's job is done by the firmware.\r\n\r\nYep, such a dependency is not good for firmware case.\r\n\r\nWhat's your opinion about device resource allocation owner? Currently, I think two options for vm-device to decouple with vm-allocator, \r\n- one for no-firmware that allocates device resource in DeviceManager when initializing and registering device, using allocate_callback given by vm-allocator.\r\n- another one gives a light device registering API whose resources are allocated before by vmm or firmware. This means lifetime management would be done by vmm.\r\n\r\nOf course, we can have both way together in vm-device, so callback can be `Option<>`.", "updated_at": "2019-07-22T10:10:23Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/513683130", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-513683130", "created_at": "2019-07-22T07:56:16Z", "id": 513683130, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMzY4MzEzMA=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@liujing2 I would propose a third one (it's in line with my previous comment: https://github.com/rust-vmm/community/issues/33#issuecomment-511375675):\r\n- the DeviceManager registers devices for which the resources are already \"allocated\" by a third party crate. In this case the third-party crate can be either vm-allocator, something dummy or whatever else that depends on the scope and implementation of the VMM.\r\n\r\nThe reason I am pushing for this design is because I would like to see a clear separation of concerns whenever possible in rust-vmm components. For the components that we are discussing in this issue, the way I see the separation of concerns is as follows (this is my unfiltered brain dump):\r\n- vm-device: this crate is responsible for managing devices. Because it manages devices it needs to define the type of Devices that it manages. The type of devices it manages is generic and defined as a trait (Device). The trait might need some other helper types like the resources that are needed by the device (for example an IRQ number). All the resources needed by the device should also be generic (if possible) and defined in this crate. But as I said in the beginning of this description, the main responsibility of the vm-device crate is to manage devices, so the crate will also have a DeviceManager.\r\n- vm-allocator: this crate is responsible for allocating various resources needed by a VMM. As it's not really feasible to have allocators for **all** the resources a VMM might need, the vm-allocator implements a few common resource allocators, but allows the users of the crate to implement their own by exporting a Trait for `ResourceAllocator`.\r\n \r\nLet me know what you think.\r\nPing: @liujing2 @jiangliu @alexandruag @bonzini  @sameo \r\n", "updated_at": "2019-07-22T09:41:11Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/513719793", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-513719793", "created_at": "2019-07-22T09:41:11Z", "id": 513719793, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMzcxOTc5Mw=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> @liujing2 I would propose a third one (it's in line with my previous comment: [#33 (comment)](https://github.com/rust-vmm/community/issues/33#issuecomment-511375675)):\r\n> \r\n> * the DeviceManager registers devices for which the resources are already \"allocated\" by a third party crate. In this case the third-party crate can be either vm-allocator, something dummy or whatever else that depends on the scope and implementation of the VMM.\r\n> \r\n> The reason I am pushing for this design is because I would like to see a clear separation of concerns whenever possible in rust-vmm components. For the components that we are discussing in this issue, the way I see the separation of concerns is as follows (this is my unfiltered brain dump):\r\n> \r\n> * vm-device: this crate is responsible for managing devices. Because it manages devices it needs to define the type of Devices that it manages. The type of devices it manages is generic and defined as a trait (Device). The trait might need some other helper types like the resources that are needed by the device (for example an IRQ number). All the resources needed by the device should also be generic (if possible) and defined in this crate. But as I said in the beginning of this description, the main responsibility of the vm-device crate is to manage devices, so the crate will also have a DeviceManager.\r\n> * vm-allocator: this crate is responsible for allocating various resources needed by a VMM. As it's not really feasible to have allocators for **all** the resources a VMM might need, the vm-allocator implements a few common resource allocators, but allows the users of the crate to implement their own by exporting a Trait for `ResourceAllocator`.\r\n> \r\n> Let me know what you think.\r\n> Ping: @liujing2 @jiangliu @alexandruag @bonzini @sameo\r\n\r\nI like this idea. \r\nThe vm-device crate should concentrate on device operations, such read/write/suspend/resume/migrate etc, and all resources needed should be allocated/assigned by the vmm.\r\nAnd for some types of resources, the VMM would not only allocate resources for device, but also need to provide methods to manage those resources. Take interrupt as an example, the VMM may need to provide an  Interrupt object with irq and methods to mask/unmask/trigger the irq.", "updated_at": "2019-07-22T14:42:00Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/513821143", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-513821143", "created_at": "2019-07-22T14:42:00Z", "id": 513821143, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMzgyMTE0Mw=="}, {"user": {"following_url": "https://api.github.com/users/jiangliu/following{/other_user}", "url": "https://api.github.com/users/jiangliu", "site_admin": false, "gists_url": "https://api.github.com/users/jiangliu/gists{/gist_id}", "node_id": "MDQ6VXNlcjE5MzE1MTY=", "starred_url": "https://api.github.com/users/jiangliu/starred{/owner}{/repo}", "gravatar_id": "", "id": 1931516, "events_url": "https://api.github.com/users/jiangliu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/1931516?v=4", "login": "jiangliu", "repos_url": "https://api.github.com/users/jiangliu/repos", "subscriptions_url": "https://api.github.com/users/jiangliu/subscriptions", "followers_url": "https://api.github.com/users/jiangliu/followers", "html_url": "https://github.com/jiangliu", "received_events_url": "https://api.github.com/users/jiangliu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/jiangliu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "When enabling MSI for Virtio MMIO transport layer, I feel it's a good idea to decouple resource allocate from the vm-device crate. Otherwise we need to pass down the vmfd(need to setup MSI IRQ) to the device/device manager.", "updated_at": "2019-07-22T14:44:15Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/513822187", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-513822187", "created_at": "2019-07-22T14:44:15Z", "id": 513822187, "node_id": "MDEyOklzc3VlQ29tbWVudDUxMzgyMjE4Nw=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "\r\n> * vm-device: this crate is responsible for managing devices. Because it manages devices it needs to define the type of Devices that it manages. The type of devices it manages is generic and defined as a trait (Device). The trait might need some other helper types like the resources that are needed by the device (for example an IRQ number). All the resources needed by the device should also be generic (if possible) and defined in this crate. But as I said in the beginning of this description, the main responsibility of the vm-device crate is to manage devices, so the crate will also have a DeviceManager.\r\n> * vm-allocator: this crate is responsible for allocating various resources needed by a VMM. As it's not really feasible to have allocators for **all** the resources a VMM might need, the vm-allocator implements a few common resource allocators, but allows the users of the crate to implement their own by exporting a Trait for `ResourceAllocator`.\r\n> \r\nDose this mean vm-device will consume `ResourceAllocator trait` defined in vm-allocator to request required resources? I would go further and even eliminate the necessary for vm-device's dependency on vm-allocator. The implementation would be:\r\n- vm-device: define a `ResourceHelper` trait (you can choose a better name) that need VMM to pass in a instance of it and internally vm-device uses it to satisfy its resource requirements.\r\n- vm-allocator: define whatever the actual allocators, whether expose a `ResourceAllocator trait` is not important here.\r\n- vmm: implement `ResourceHelper` by using allocators from vm-allocator and pass the `ResourceHelper` instance to vm-device (e.g. DeviceManager).\r\n", "updated_at": "2019-07-23T01:34:58Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/514017763", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-514017763", "created_at": "2019-07-23T01:34:58Z", "id": 514017763, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNDAxNzc2Mw=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "> Dose this mean vm-device will consume `ResourceAllocator trait` defined in vm-allocator to request required resources?\r\n\r\nNo, quite the opposite. This means that vm-device will **NOT** depend at all on vm-allocator (not even on traits from vm-allocator). If you look at the high level, I am proposing almost the same thing as you are.\r\n\r\n> I would go further and even eliminate the necessary for vm-device's dependency on vm-allocator. The implementation would be:\r\n> \r\n>     * vm-device: define a `ResourceHelper` trait (you can choose a better name) that need VMM to pass in a instance of it and internally vm-device uses it to satisfy its resource requirements.\r\n> \r\n\r\nI would also prefer for the vm-device to define a `Resource` trait that needs to be implemented by all resources needed by a `Device`. I am not sure if this is feasible though, we will need to check. The question I have is whether we can have a generic resource type. What do you mean with \"internally vm-device uses it to satisfy its resource requirements\"?\r\n\r\n>     * vm-allocator: define whatever the actual allocators, whether expose a `ResourceAllocator trait` is not important here.\r\n> \r\n\r\nThis can be discussed in detail on the vm-allocator issue: https://github.com/rust-vmm/community/issues/58\r\n\r\n>     * vmm: implement `ResourceHelper` by using allocators from vm-allocator and pass the `ResourceHelper` instance to vm-device (e.g. DeviceManager).\r\n\r\nYap, that's pretty much what I propose as well.\r\n\r\n", "updated_at": "2019-07-23T08:35:17Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/514111207", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-514111207", "created_at": "2019-07-23T08:35:17Z", "id": 514111207, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNDExMTIwNw=="}, {"user": {"following_url": "https://api.github.com/users/chao-p/following{/other_user}", "url": "https://api.github.com/users/chao-p", "site_admin": false, "gists_url": "https://api.github.com/users/chao-p/gists{/gist_id}", "node_id": "MDQ6VXNlcjExMzczNjUy", "starred_url": "https://api.github.com/users/chao-p/starred{/owner}{/repo}", "gravatar_id": "", "id": 11373652, "events_url": "https://api.github.com/users/chao-p/events{/privacy}", "avatar_url": "https://avatars3.githubusercontent.com/u/11373652?v=4", "login": "chao-p", "repos_url": "https://api.github.com/users/chao-p/repos", "subscriptions_url": "https://api.github.com/users/chao-p/subscriptions", "followers_url": "https://api.github.com/users/chao-p/followers", "html_url": "https://github.com/chao-p", "received_events_url": "https://api.github.com/users/chao-p/received_events", "type": "User", "organizations_url": "https://api.github.com/users/chao-p/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "\r\n> > I would go further and even eliminate the necessary for vm-device's dependency on vm-allocator. The implementation would be:\r\n> > ```\r\n> > * vm-device: define a `ResourceHelper` trait (you can choose a better name) that need VMM to pass in a instance of it and internally vm-device uses it to satisfy its resource requirements.\r\n> > ```\r\n> \r\n> I would also prefer for the vm-device to define a `Resource` trait that needs to be implemented by all resources needed by a `Device`. I am not sure if this is feasible though, we will need to check. The question I have is whether we can have a generic resource type. What do you mean with \"internally vm-device uses it to satisfy its resource requirements\"?\r\n\r\nI'm not quite clear on what you mean on \u201c`Resource` trait\u201d and \u201cgeneric resource type\u201d. I guess it's better to show some pseudo code here. My though on 'ResourceHelper' trait would look like:\r\n```rust\r\npub trait ResourceHelper {\r\n    fn alloc_dev_id(&mut self) -> i32 {}\r\n    fn free_dev_id(&mut self, id: u32) {}\r\n\r\n    fn alloc_pio(&mut self, addr: Option<GuestAddress>, size: GuestUsize, align: Option<GuestUsize>) -> Result<GuestAddress> {}\r\n    fn free_pio(&mut self, addr: GuestAddress, size: GuestUsize) {}\r\n\r\n    fn alloc_mmio(&mut self, addr: Option<GuestAddress>, size: GuestUsize, align: Option<GuestUsize>) -> Result<GuestAddress> {}\r\n    fn free_mmio(&mut self, addr: GuestAddress, size: GuestUsize) {}\r\n\r\n    fn alloc_irq(&mut self, irq: Option<u32>) -> Result<u32> {}\r\n    fn free_irq(&mut self, irq: u32) {}\r\n}\r\n```\r\nvmm will need to instantiate this trait and pass it to DeviceManager and then DeviceManger can call the methods on this trait to allocate the resources for device on creating.\r\n\r\n", "updated_at": "2019-07-24T06:58:02Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/514506151", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-514506151", "created_at": "2019-07-24T06:58:02Z", "id": 514506151, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNDUwNjE1MQ=="}, {"user": {"following_url": "https://api.github.com/users/andreeaflorescu/following{/other_user}", "url": "https://api.github.com/users/andreeaflorescu", "site_admin": false, "gists_url": "https://api.github.com/users/andreeaflorescu/gists{/gist_id}", "node_id": "MDQ6VXNlcjI4MTU5NDQ=", "starred_url": "https://api.github.com/users/andreeaflorescu/starred{/owner}{/repo}", "gravatar_id": "", "id": 2815944, "events_url": "https://api.github.com/users/andreeaflorescu/events{/privacy}", "avatar_url": "https://avatars0.githubusercontent.com/u/2815944?v=4", "login": "andreeaflorescu", "repos_url": "https://api.github.com/users/andreeaflorescu/repos", "subscriptions_url": "https://api.github.com/users/andreeaflorescu/subscriptions", "followers_url": "https://api.github.com/users/andreeaflorescu/followers", "html_url": "https://github.com/andreeaflorescu", "received_events_url": "https://api.github.com/users/andreeaflorescu/received_events", "type": "User", "organizations_url": "https://api.github.com/users/andreeaflorescu/orgs"}, "issue_url": "https://api.github.com/repos/rust-vmm/community/issues/33", "body": "@chao-p I was more aiming at having pre-allocated resources. Having a resource helper that is responsible for allocation still implies that the DeviceManager depends on a `allocator`, the only difference is that the `allocator` is defined in vm-device and not in vm-allocator.\r\n\r\nThis comment https://github.com/rust-vmm/community/issues/33#issuecomment-511375675 has the pseudocode for what I mean with pre-allocated resources. Please check it out.\r\n\r\n ", "updated_at": "2019-07-24T07:42:07Z", "url": "https://api.github.com/repos/rust-vmm/community/issues/comments/514518712", "author_association": "MEMBER", "html_url": "https://github.com/rust-vmm/community/issues/33#issuecomment-514518712", "created_at": "2019-07-24T07:42:07Z", "id": 514518712, "node_id": "MDEyOklzc3VlQ29tbWVudDUxNDUxODcxMg=="}]